<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SPA Demo (Single Page Application) - YpsilonEventHandler</title>
    <meta name="description" content="YpsilonEventHandler - Single Page Application [SPA] Example Page">
    <link rel="icon" type="image/x-icon" href="./favicon.ico">
    <link rel="stylesheet" type="text/css" href="./assets/main.css">
    <style>
        /* Note: This demo uses modern CSS nesting syntax.
           If your browser doesn't support it, some styling may not work,
           but the JavaScript functionality will work perfectly. */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        html {
            scroll-behavior: smooth;
        }
        body {
            padding-bottom: 210px;
            line-height: 1.6;
            background: #f5f5f5;
            font-family: system-ui, sans-serif;

            .scroll-to-top {
                padding: 6px 12px;
                position: fixed;
                bottom: -4px;
                right: -40px;
                z-index: 1001;
                opacity: 0;
                font-size: 22px;

            }

            .scroll-to-top:hover {
                transform: translateY(0);
            }
        }

        body.y-scrolled .scroll-to-top {
            bottom: 4px;
            right: 4px;
            opacity: 1;
        }

        ul {
            margin: 0;
            padding: 0;
            list-style-type: none;

            &.assigned-listener-list {
                margin-top: 15px;
            }
            li {
                margin: 0;
                padding: 0;

                li {
                    display: flex;
                    align-items: center;
                    counter-increment: section;

                    &::before {
                        content: counters(section, ".") ". ";
                        padding: 6px 6px 6px 8px;
                        display: block;
                        color: #aaa;
                        font-size: 14px;
                    }
                    &:not(:last-of-type) {
                        border-bottom: 1px solid #f1f1f1;
                    }
                }
                span {
                    display: block;
                    &.selector {
                        padding: 8px 10px;
                        font-weight: bold;
                        background: #f4f4f4;
                    }
                    &.config {
                        padding: 10px 2px;
                    }
                }
            }
        }

        .table-container {
            margin: 20px 0;
            overflow: auto;

            table,
            td {
                border: 1px solid rgb(129, 114, 114);
                border-collapse: collapse;
            }

            table {
                width: 100%;

                td,
                tr {
                    padding: 8px;
                    white-space: nowrap;
                }
            }
        }

        del {
            text-decoration-line: overline underline line-through;
            text-decoration-color: #f00;
            text-decoration-thickness: auto;
            text-shadow: 0px 2px 11px #f00;
            opacity: .8;
        }

        ins { font-weight: bold; }

        hr { margin: .5rem 0 .75rem; }

        .d-none { display: none; }

        .flex-center-center {
            display: flex;
            align-items: center;
            justify-content: center;

            a, small {
                margin: 0 5px;
            }

            &.src-nav {
                margin: 2.5rem 1.5rem;
            }
        }

        .container {
            margin: 0 auto;
            padding: 0 20px;
            max-width: 1200px;
        }

        .header {
            margin-bottom: 30px;
            padding: 40px 0;
            text-align: center;
            color: white;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .section {
            margin: 30px 0;
            padding: 30px;
            border-radius: 10px;
            background: white;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);

            &:last-of-type {
                margin: 30px 0 0;
            }
            h2 {
                margin-bottom: 20px;
                padding-bottom: 10px;
                color: #333;
                border-bottom: 2px solid rgb(122, 145, 248);
            }
        }

        .btn {
            margin: 5px 2px;
            padding: 12px 24px;
            display: inline-flex;
            align-items: center;
            white-space: nowrap;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            color: white;
            background: #667eea;
            cursor: pointer;
            transition: all .3s ease;

            &:hover {
                background: #5a6fd8;
                transform: translateY(-2px);
            }
            &.btn-success {
                background: #28a745;

                &:hover { background: #218838; }
            }
            &.btn-danger {
                background: #dc3545;

                &:hover { background: #c82333; }
            }
            &.btn-warning {
                background: #ffc107;
                color: #212529;

                &:hover { background: #e0a800; }
            }

            &.svg-btn {
                padding: 0;

                svg {
                    padding: 8px;
                    height: 40px;
                    width: 40px;
                    display: block;
                }
            }
        }

        label {
            position: relative;

            span {
                transition: all .3s ease-in-out;
            }
        }

        code {
            font-weight: bold;
        }

        #auto-target-toggle {
            position: absolute;
            left: 18px;
            opacity: .1;
            transform: scale(1.5);

            + span {
                padding: 12px 18px 12px 46px;
                width: 100%;
                display: block;
                box-shadow: 0 0 2px 2px #17a2b855;
            }
            &:checked {
                opacity: .6;

                + span {
                    box-shadow: 0 0 4px 2px #2c9444ee;

                    span {
                        color: #2c9444;
                    }
                }
            }
        }

        .dynamic-grid {
            display: grid;
            gap: 20px;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        }

        .card {
            padding: 20px;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            background: #f8f9fa;
            transition: all .3s ease;

            &:hover {
                transform: translateY(-5px);
                box-shadow: 0 8px 25px rgba(0,0,0,0.15);
            }
            h3 {
                margin-bottom: 10px;
                color: #495057;
            }
        }

        .todo-item {
            margin: 10px 0;
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid #ddd;
            border-radius: 6px;
            background: #fff;
            transition: all .3s ease;

            &.completed {
                text-decoration: line-through;
                opacity: 0.7;
                background: #d4edda;
            }

            .todo-content {
                width: 100%;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }
        }

        .form-group {
            margin: 15px 0;

            label {
                margin-bottom: 5px;
                display: block;
                font-weight: bold;
                color: #555;
            }

            &.dynamic-group {
                margin: 5px 0;
                display: flex;
                align-items: center;

                &:last-of-type {
                    margin-bottom: 20px;
                }
                label,
                button {
                    white-space: nowrap;
                }
                label {
                    margin: 0 10px 0 0;
                    opacity: .7;
                }
            }
        }

        .form-control {
            padding: 10px;
            width: 100%;
            font-size: 14px;
            border: 1px solid #ddd;
            border-radius: 4px;

            &:focus {
                outline: none;
                border-color: #667eea;
                box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.2);
            }
        }

        .counter {
            margin-left: 10px;
            padding: 5px 10px;
            display: inline-block;
            border-radius: 20px;
            font-size: 12px;
            color: white;
            background: #667eea;
        }

        .log-container {
            font-family: monospace;
            font-size: 12px;

            h2 {
                margin: 5px 0 15px;
            }
            .log {
                margin: 15px 0;
                padding: 15px;
                height: 200px;
                background: #f5f5f5;
                border-radius: 6px;
                border: 1px solid #dee2e6;
                overflow-y: auto;

                .log-entry {
                    margin: 2px 0;
                    padding: 2px 0;
                    white-space: nowrap;

                    &:not(:last-of-type) {
                        border-bottom: 1px solid #eee;
                    }
                }
            }
            .show-logs-always {
                max-width: 1040px;
                position: fixed;
                left: 2px;
                bottom: 1px;
                z-index: 11111;
                box-shadow: 0 0 8px 2px #c1b3b3;

                .log {
                    margin: 0;
                    overscroll-behavior: contain;
                }
            }
        }

        body.show-logs-always {
            padding-bottom: 400px;

            &.y-scroll-bottom {
                .show-logs-always {
                    box-shadow: 0 0 8px 0px #c1b3b3;
                    bottom: 180px;
                    opacity: .85;

                    .log {
                        max-height: 128px;
                    }
                }
            }
        }

        .tabs {
            margin: 20px 0;
            display: flex;
            overflow: hidden;
            border-radius: 6px;
            background: #f8f9fa;

            .tab {
                flex: 1;
                padding: 15px;
                text-align: center;
                cursor: pointer;
                border: none;
                background: #e9ecef;
                transition: all .3s ease;

                &.active {
                    color: white;
                    background: #667eea;
                }
            }
        }

        .tab-content {
            padding: 20px;
            display: none;
            border-radius: 6px;
            background: white;

            &.active { display: block; }
        }

        .badge {
            margin-left: 8px;
            padding: 4px 8px;
            display: inline-block;
            border-radius: 12px;
            font-size: 11px;
            color: white;
            background: #6c757d;
        }

        .notification {
            padding: 6px;
            max-width: 380px;
            position: fixed;
            top: 2px;
            right: 20px;
            z-index: 1000;
            border-radius: 6px;
            color: white;
            background: linear-gradient(135deg, #667eeaaa 0%, #764ba2ee 100%);
            transform: translateX(100%);
            transition: all .4s ease-in-out;
            color: transparent;

            &.show { transform: translateX(0); }
        }

        .toast {
            margin-bottom: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #28a745;
            color: white;
            border-radius: 4px;
            cursor: default;
            transition: all .4s ease-in-out;

            span {
                padding: 0 15px;
                display: block;
                max-width: 95%;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }
            button {
                padding: 10px 15px;
                background:rgb(35, 126, 56);
                border: none;
                color: white;
                cursor: pointer;
                font-weight: bold;
                font-size: 22px;
            }
            &:not(:last-of-type) {
                border-bottom: 1px solid #c3c3c3;
            }
        }

        .stats {
            margin: 20px 0;
            display: grid;
            gap: 20px;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            line-height: 1;

            .stat-card {
                padding: 20px;
                color: white;
                text-align: center;
                border-radius: 10px;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            }
            .stat-number {
                margin-bottom: 10px;
                font-size: 2em;
                font-weight: bold;
            }
            .stat-label {
                font-size: 0.9em;
                opacity: 0.9;
            }
        }

        .stats-placeholder {
            height: 0;
        }

        .stats-section {
            width: 100%;
            position: absolute;
            transition: all .3s ease;

            .container {
                margin: 0 auto;
                padding: 0 20px;

                .section { margin: 0; }
            }
            &.sticky {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                z-index: 1000;
                background: rgba(255, 255, 255, 0.75);
                backdrop-filter: blur(10px);
                border-bottom: 1px solid rgba(102, 126, 234, 0.2);
                box-shadow: 0 0px 16px 1px rgba(0, 0, 0, 0.3);

                .container {
                    padding: 0 20px;
                }
                .section {
                    margin: 0;
                    padding: 0 4px 1px;
                    background: transparent;
                    box-shadow: none;
                }
                .stats {
                    margin: 5px 0;
                    gap: 5px;
                }
                .stat-card {
                    padding: 4px 6px;
                    border-radius: 3px;
                }
                .stat-number {
                    margin: 4px 0;
                    font-size: 1.2em;
                }
                .stat-label {
                    margin-bottom: 4px;
                    font-size: 0.7em;
                }
                h2 {
                    display: none;
                }
            }
        }

        .ypsi-buttons {
            flex-wrap: wrap;
        }

        .scroll-area {
            height: 300px;
            overflow-y: scroll;
            background: linear-gradient(to bottom, #e3f2fd, #bbdefb);
            border: 2px solid #2196f3;
            border-radius: 8px;
            padding: 20px;

            .scroll-content {
                background: linear-gradient(to bottom, #fff3e0, #ffcc02);
                padding: 20px;
                border-radius: 4px;
            }
        }

        .footer {
            padding: 20px;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            color: white;
            text-align: center;
            white-space: nowrap;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            transform: translateY(100%);
            transition: transform .3s ease;

            &.visible {
                transform: translateY(0);
            }
            h3 {
                margin-bottom: 10px;
            }
            p {
                margin: 5px 0;
                opacity: 0.9;
            }
            a {
                color: #fff;
            }
        }

        .nav-container {
            padding: 0;
            box-shadow: 0 0 0 #6b7894;
            background: #f7f7f7;
            margin: 20px 0 0;
        }

        @media only screen and (min-width: 640px) {
            .ypsi-buttons {
                display: flex;
                justify-content: space-between;

                .helper-btn,
                .starter-btn {
                    display: flex;
                    align-items: center;
                }
            }
        }

        @media only screen and (max-width: 480px) {
            body {
                padding-bottom: 260px;
            }
            .stats-section {
                .stats {
                    display: flex;
                    flex-wrap: wrap;
                    gap: 5px;
                }
                .stat-card {
                    padding: 4px 6px;
                    flex: 1 32%;
                    border-radius: 3px;

                    .stat-label {
                        white-space: nowrap;
                        overflow: hidden;
                        text-overflow: ellipsis;
                        margin: 0 auto;
                        max-width: 90px;
                    }
                    .stat-number {
                        margin-bottom: 1px;
                        font-size: 1.5em;
                    }
                }
            }
        }

        .y-fade-in {
            animation: yFadeIn .4s ease forwards;
        }
        .y-blink {
            animation: yFadeIn .4s ease forwards, yBlink 1.5s ease forwards;
        }
        @keyframes yFadeIn { from { opacity: 0 } to { opacity: 1 } }
        @keyframes yBlink  { from { color: #0fec3f } to { color: #222 } }
    </style>
</head>
<body class="y-scroll-top">
    <div class="header y-fade-in">
        <div class="container">
            <h1>üöÄ YpsilonEventHandler SPA Demo</h1>
            <p>Demonstrating the power of event delegation with dynamic content</p>
            <p><strong>‚ö° ONLY 10 EVENT LISTENERS for this ENTIRE SPA! ‚ö°</strong></p>
            <p><strong>ONE handler on body handles ALL events - no matter when elements are created!</strong></p>
        </div>
    </div>

    <div class="stats-section y-fade-in" id="stats-section">
        <div class="container">
            <!-- Stats Dashboard -->
            <div class="section">
                <h2>üìä Live Statistics</h2>
                <div class="stats">
                    <div class="stat-card">
                        <div class="stat-number" id="click-count">0</div>
                        <div class="stat-label">Total Clicks</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="element-count">0</div>
                        <div class="stat-label">Dynamic Elements</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="todo-count">0</div>
                        <div class="stat-label">Todo Items</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="event-count">0</div>
                        <div class="stat-label">Events Handled</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="scroll-position">0</div>
                        <div class="stat-label">Scroll Position</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Placeholder to prevent layout shift when stats become sticky -->
    <div class="stats-placeholder" id="stats-placeholder"></div>

    <div class="container y-fade-in">

        <!-- Dynamic Content Creator -->
        <div class="section">
            <h2>üéØ Dynamic Content Creator</h2>
            <p>Create new elements dynamically - they work instantly without new listeners!</p>

            <div style="margin: 20px 0;">
                <button class="btn btn-success y-btn" data-action="createCard">‚ûï Create Card</button>
                <button class="btn btn-warning y-btn" data-action="createButton">üîò Create Button</button>
                <button class="btn btn-danger y-btn" data-action="clearAll">üóëÔ∏è Clear All</button>
            </div>

            <div class="dynamic-grid" id="dynamic-container"><!-- Dynamic elements --></div>
        </div>

        <!-- Smart Target Resolution Demo -->
        <div class="section">
            <h2>üõ∏ Smart Target Resolution Demo</h2>
            <p>Try this live demo to see how we solve the common "SVG-in-button" event handling issue. Toggle the feature below to see the difference in action!</p>

            <div style="margin: 20px 0; border-radius: 8px; background: #f8f9fa;">
                <label style="display: flex; flex-wrap: wrap; align-items: center; cursor: pointer; font-weight: bold;">
                    <input type="checkbox" id="auto-target-toggle" style="margin-right: 10px;">
                    <span>
                        <span>üß† Enable Smart Target Resolution (autoTargetResolution)</span>
                        <br />
                        <small>When enabled, clicks on nested elements like SVGs will resolve to their intended parent buttons</small>
                    </span>
                </label>
            </div>

            <div style="margin: 20px 0 0;">
                <div style="display:flex">
                    <button class="btn btn-info svg-btn y-btn" data-action="showAlert">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" style="vertical-align: -3px;">
                            <path d="M24 12c0 6.6274-5.3726 12-12 12S0 18.6274 0 12 5.3726 0 12 0s12 5.3726 12 12zM12 2C6.4772 2 2 6.4772 2 12s4.4772 10 10 10 10-4.4772 10-10S17.5228 2 12 2zm0 13c.5523 0 1 .4477 1 1s-.4477 1-1 1-1-.4477-1-1 .4477-1 1-1zm-1-7c0-.5523.4477-1 1-1s1 .4477 1 1v5c0 .5523-.4477 1-1 1s-1-.4477-1-1V8z" fill="white" fill-rule="evenodd" />
                        </svg>
                    </button>
                    <button class="btn btn-warning y-btn" data-action="showAlert">Working Test</button>
                </div>
            </div>

            <div style="margin:18px 0 0;padding:8px 12px;font-size:14px;color:#444;background:#edf3f477;box-shadow: 0 0 2px 2px #3a4c4e33;">
                <p>One frequent problem when using event delegation is that <code>event.target</code> can refer to a nested child element rather than the actual clickable element you are targeting.
                <br />A typical example: clicking an <code>SVG</code> inside a button triggers the SVG as the event target‚Äî*not* the button‚Äîdue to DOM hierarchy and event bubbling.</p>
            </div>
        </div>

        <!-- Todo List Manager -->
        <div class="section">
            <h2>‚úÖ Todo List Manager</h2>
            <p>Add, complete, and delete todos - all handled by the same body listener!</p>

            <div class="form-group">
                <input type="text" class="form-control y-input" id="todo-input"
                    placeholder="Enter a new todo..." data-action="todo-input">
                <button class="btn y-btn" data-action="addTodo" style="margin-top: 10px;">‚ûï Add Todo</button>
            </div>

            <div id="todo-container"><!-- Todo items --></div>
        </div>

        <!-- Tab System -->
        <div class="section">
            <h2>üìë Dynamic Tab System</h2>
            <p>Switch between tabs - all handled by event delegation!</p>

            <div class="tabs">
                <button class="tab active" data-action="switchTab" data-tab="tab1">Tab 1</button>
                <button class="tab" data-action="switchTab" data-tab="tab2">Tab 2</button>
                <button class="tab" data-action="switchTab" data-tab="tab3">Tab 3</button>
                <button class="btn y-btn" data-action="addTab" style="margin-left: auto;">‚ûï Add Tab</button>
            </div>

            <div class="tab-content active" id="tab1">
                <h3>Tab 1 Content</h3>
                <p>This is the content of tab 1. Click buttons below to test event delegation:</p>
                <button class="btn y-btn" data-action="tabAction" data-message="Tab 1 button clicked!">Click Me</button>
                <button class="btn btn-success y-btn" data-action="createElementInTab" data-target="tab1">Create Element</button>
            </div>

            <div class="tab-content" id="tab2">
                <h3>Tab 2 Content</h3>
                <p>This is the content of tab 2. These buttons were here from the start:</p>
                <button class="btn y-btn" data-action="tabAction" data-message="Tab 2 button clicked!">Click Me</button>
                <button class="btn btn-warning y-btn" data-action="createElementInTab" data-target="tab2">Create Element</button>
            </div>

            <div class="tab-content" id="tab3">
                <h3>Tab 3 Content</h3>
                <p>This is the content of tab 3. Event delegation works everywhere:</p>
                <button class="btn y-btn" data-action="tabAction" data-message="Tab 3 button clicked!">Click Me</button>
                <button class="btn btn-danger y-btn" data-action="createElementInTab" data-target="tab3">Create Element</button>
            </div>
        </div>

        <!-- Form Interactions -->
        <div class="section">
            <h2>üìù Form Interactions</h2>
            <p>All form events handled by the same body listener with delegation:</p>

            <div class="form-group">
                <label for="name-input">Name:</label>
                <input type="text" id="name-input" class="form-control y-input" data-action="name-input" placeholder="Enter your name">
            </div>

            <div class="form-group">
                <label for="email-input">Email:</label>
                <input type="email" id="email-input" class="form-control y-input" data-action="email-input" placeholder="Enter your email">
            </div>

            <div class="form-group">
                <label for="message-input">Message:</label>
                <textarea id="message-input" class="form-control y-input" data-action="message-input" placeholder="Enter your message" rows="3"></textarea>
            </div>

            <button class="btn y-btn" data-action="submitForm">üì® Submit Form</button>
            <button class="btn btn-warning y-btn" data-action="addFormField">‚ûï Add Field</button>
        </div>

        <!-- Scroll area -->
        <div class="section">
            <h2>Scroll Test (Passive Listeners)</h2>
            <p>Scroll in the area below to test passive scroll events:</p>

            <div class="scroll-area" id="scroll-area">
                <div class="scroll-content">
                    <h3>Scrollable Content</h3>
                    <p>This scroll area demonstrates passive event listeners.</p>
                    <p>When you scroll here, the event will be handled with passive:true automatically.</p>
                    <p>This improves performance by telling the browser that preventDefault() won't be called.</p>
                    <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p>
                    <p>Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.</p>
                    <p>Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris.</p>
                    <p>Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore.</p>
                    <p>Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia.</p>
                    <p>Keep scrolling to see more content...</p>
                    <p>The scroll events are being logged to the output area above.</p>
                    <p>Notice how smooth the scrolling is with passive listeners!</p>
                    <p>This is the power of automatic passive listener detection.</p>
                    <p>YpsilonEventHandler handles this optimization automatically.</p>
                    <p>No manual configuration needed!</p>
                    <p>You're near the bottom now.</p>
                    <p>Final paragraph of scrollable content.</p>
                </div>
            </div>
        </div>

        <!-- Assigned Event Listeners -->
        <div class="section" id="ypsilon-assigned">
            <h2>üì° Assigned Event Listeners</h2>
            <p><strong>These are the event listeners assigned to this entire SPA!</strong></p>
            <p>No additional listeners will be created - all dynamic content uses these same <del>5</del> <ins>10</ins> listeners via event delegation.</p>
            <div></div>
            <hr />
            <div class="nav-container">
                <!-- Navigation to other examples -->
                <nav class="main-nav">
                    <div>
                        <a href="./index.html" class="btn-primary">Start</a>
                        <a href="./basic-example.html" class="btn-secondary">Basic Example</a>
                        <a href="./reactive-y.html" class="btn-danger">Reactive Demo</a>
                        <a href="./single-listener-multiple-actions.html" class="btn-purple">Single Listener</a>
                        <a href="./spa.html" class="btn-disabled">SPA Demo</a>
                        <a href="./ai-reviews.html" class="btn-warning">AI Reviews</a>
                        <a href="https://github.com/eypsilon/YpsilonEventHandler" class="btn-dark">GitHub</a>
                    </div>
                </nav>
            </div>
        </div>

        <!-- Staggeringly Performant -->
        <div class="section">
            <h2>üèÜ Staggeringly Performant</h2>
            <p>Just click or focus on any button that generates something visual, like "‚ûï Create Card" and keep enter pressed! While you generate, scroll using the scrollbar. It allows us to scroll fast. Try it for yourself, it took me seconds.</p>

            <div class="table-container">
                <table class="performance-table">
                    <tr>
                        <td class="stat-label-number">Clicks: <b>2,887</b></td>
                        <td class="stat-label-number">Dynamic Elements: <b>2,627</b></td>
                        <td class="stat-label-number">Events Handled: <b>3,664</b></td>
                        <td class="stat-label-number">Scroll Position: <b>143k</b></td>
                        <td class="stat-label-number">Event Listeners: <b>6</b></td>
                    </tr>
                </table>
            </div>

            <p><em>All achieved with ~500 lines of vanilla JavaScript + native handleEvent interface.</em> One has to see it to believe it.</p>
        </div>

        <!-- Event Log -->
        <div class="section log-wrapper">
            <div class="log-container">
                <h2>üìã Event Log</h2>
                <p>Watch how ONE body listener handles ALL events <small>(max: 50)</small>:</p>
                <div class="log-wrapper">
                    <div class="log y-fade-in" id="event-log">
                        <div class="log-entry">Event log will appear here...</div>
                    </div>
                    <div class="helper-btn">
                        <label class="btn" title="Show Event Log Always"
                            style="padding:10px;position:absolute;bottom:100%;z-index:1;background:#dad3d3;border:1px solid #bbb;">
                            <input type="checkbox" name="show-logs-always" value="true" data-action="showLogsAlways" checked>
                        </label>
                    </div>
                </div>
            </div>
            <div class="ypsi-buttons">
                <div class="helper-btn">
                    <button class="btn btn-warning y-btn" data-action="clearLog">üóëÔ∏è Clear Log</button>
                    <button class="btn y-btn" data-action="debugHandler" style="background: #6f42c1;">üîç Debug Handler</button>
                    <button class="btn y-btn" data-action="testDispatch" style="background: #fd7e14;">üî• Test Dispatch</button>
                    <label class="btn main-toggle" title="Show Event Log Always" style="font-size: 11px;">
                        <input type="checkbox" name="show-logs-always" value="true" data-action="showLogsAlways" checked>
                        üìå Always
                    </label>
                </div>
                <div class="starter-btn">
                    <span id="handler-status" style="margin-right: 10px; font-weight: bold; color: #28a745;">ACTIVE</span>
                    <button class="btn" style="background: #28a745;" id="recreate-btn" disabled>üîÑ Recreate Handler</button>
                    <button class="btn" style="background: #dc3545;" id="destroy-btn">üíÄ Destroy Handler</button>
                </div>
            </div>
        </div>

    </div>

    <!-- Notification -->
    <div class="notification" id="notification">Action completed!</div>

    <!-- Scroll to top -->
    <div class="scroll-to-top-container">
        <button type="button" class="scroll-to-top btn y-btn" data-action="scrollToTop">‚ñ≤</button>
    </div>

    <div class="flex-center-center src-nav">
        <small>¬© Engin Ypsilon & Claude Van DOM</small> |
        <a href="https://github.com/eypsilon/YpsilonEventHandler">github</a> |
        <a href="https://www.npmjs.com/package/ypsilon-event-handler">npm</a> |
        <a href="./spa.html">reload</a>
    </div>

    <!-- Footer -->
    <div class="footer" id="footer">
        <h3>üéâ You've reached the bottom!</h3>
        <p>‚ú® This footer appeared thanks to scroll event delegation</p>
        <p>üöÄ ONE body listener handled ALL scroll events on this page</p>
        <p>üí´ YpsilonEventHandler - The power of native handleEvent interface</p>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/ypsilon-event-handler@1.7.0/ypsilon-event-handler.min.js"></script>
    <script>
        "use strict";

        const config = {
            debounce: 500,
            debounceChange: 500,
            throttle: 300,
            throttleResize: 500,
            throttleScrollArea: 400,
            threshold: {
                top: 100,
                bottom: 40,
                showFooter: 40,
            },
            notification: {
                timeout: 3000
            },
        }

        /**
         * Convention Protocol
         * Gets applied, when event.types are missing a handler
         *
         * ## body handler
         * click         handleClick(event, target)
         * keydown       handleKeydown(event, target)
         * testdispatch  handleTestdispatch(event, target)
         * change        handleChange(event, target)
         * input         handleInput(event, target)
         *
         * ## window handler
         * resize        handleResize(event, target)
         * scroll        handleScroll(event, target)
         * beforeunload  handleBeforeunload(event, target)
         */
        const customEventMap = {
            'body': [
                'click',
                'keydown',
                'testdispatch',
                { type: 'input',  debounce: config.debounce,       options: { passive: true } },
                { type: 'change', debounce: config.debounceChange, options: { passive: true } },
            ],
            'window': [
                { type: 'load',         handler:  'handleWindowLoad', options: { once: true } },
                { type: 'resize',       throttle: config.throttleResize },
                { type: 'scroll',       throttle: config.throttle },
                { type: 'beforeunload', capture:  true },
            ],
            '#scroll-area': [
                { type: 'scroll', handler: 'handleAreaScroll', throttle: config.throttleScrollArea }
            ],
        }

        // SPA Event Handler - ONE handler for the entire application!
        class SPAEventHandler extends YpsilonEventHandler {
            constructor(eventMapping, aliases, userConfig = {}) {
                // Merge outer config with default config and user config
                const mergedConfig = { ...config, ...{
                    enableStats: true,
                    autoTargetResolution: false,
                }, ...userConfig };

                super(customEventMap, {}, mergedConfig);

                // Initialize counters based on existing DOM elements (for recreate scenarios)
                this.counters = {
                    clicks: 0,
                    elements: document.querySelectorAll('.dynamic-grid > *').length,
                    todos: document.querySelectorAll('.todo-item').length,
                    events: 0
                };

                this.tabCounter = 3;
                this.updateStats();
                this.initializePlaceholder();

                // Load todos from localStorage only if DOM is empty (avoid doubling on recreate)
                if (this.counters.todos === 0) {
                    this.loadTodos();
                }
            }

            handleWindowLoad(event) {
                this.log(`üëã Window load, remove (once: true)`);

                // Initialize log visibility with proper height calculation (no click event)
                const showLogsCheckbox = document.querySelector('input[data-action="showLogsAlways"]');
                if (showLogsCheckbox && showLogsCheckbox.checked) {
                    // Call the full showLogsAlways logic to handle height calculation and layout
                    this.showLogsAlways(showLogsCheckbox);
                }
            }

            handleVisibilitychange(event) {
                // Useful to perform final actions right before user leaves
                if (document.visibilityState == 'hidden') { console.log('Bye bye!') }
            }

            // If user has interacted with the page, this acts as a
            // `prevent-data-loss` tool, a pretty unrelieable `prevent-data-loss`
            handleBeforeunload(event) {
                if (this.hasUserInteracted()) {
                    event.preventDefault();
                    event.returnValue = 'Are you sure you want to leave Ypsilon?';
                } else { // User hasn't interacted, clean up silently
                    this.destroy();
                }
            }

            handleAreaScroll(event, target) {
                this._updateStats('events');
                const scrollTop = target.scrollTop || 0;
                this.log(`üìú DIV scroll: ${Math.round(scrollTop)}px (throttled ${config.throttleScrollArea}ms)`);
            }

            handleResize(event, target) {
                this._updateStats('events');
                if (!document.querySelector('.stats-placeholder.active')) {
                    this.updatePlaceholderHeights();
                }
                const width = window.innerWidth;
                const height = window.innerHeight;
                this.log(`üìè Window resize: ${width}x${height}px (throttled ${config.throttleResize}ms)`);
            }

            handleClick(event, target) {
                this._updateStats('clicks', 'events');

                // Handle different button types based on data-action
                const action = target.dataset.action;
                if (!action) return;

                if (typeof this[action] === 'function') {
                    return this[action](target, event);
                }

                this.log(`üñ±Ô∏è Click: ${action} (${target.textContent.trim()})`);
            }

            handleInput(event, target) {
                this._updateStats('events');

                const action = target.dataset.action;
                if (!action) return;

                // Handle todo input enter key
                if (action === 'todo-input' && event.type === 'keydown' && event.key === 'Enter') {
                    this.addTodo();
                }

                this.log(`‚å®Ô∏è Input: ${action} = "${target.value}" (debounced ${config.debounce})`);
            }

            handleChange(event, target) {
                this._updateStats('events');

                this.log(`üîÑ Change: ${target.dataset.action || 'unknown'} = "${target.value}"`);
            }

            handleKeydown(event, target) {
                if (target.dataset.action === 'todo-input' && event.key === 'Enter') {
                    this.addTodo();
                }
            }

            handleScroll(event, target) {
                this._updateStats('events');

                const scrollY = window.scrollY || window.pageYOffset;
                const windowHeight = window.innerHeight;
                const docHeight = document.documentElement.scrollHeight;

                // Update scroll position in stats
                this.updateScrollStats(scrollY, docHeight, windowHeight);

                // Handle sticky stats
                this.updateStickyStats(scrollY);

                // Handle footer visibility
                this.updateFooterVisibility(scrollY, docHeight, windowHeight);

                // Handle body scroll classes
                this.updateScrollClasses(scrollY, docHeight, windowHeight);

                if (!this.waitingScroll) {
                    this.waitingScroll = true;

                    setTimeout(() => {
                        this.waitingScroll = false;
                        this.log(`üåê Window scroll: ${Math.round(scrollY)}px (throttled ${config.throttle})`);
                    }, 250);
                }
            }

            showLogsAlways(target) {
                const logs = this.getEventLogContainer();

                if (logs) {
                    const logContainer = logs.parentNode.parentNode;
                    const exec = target.checked ? 'add' : 'remove';

                    logContainer.style.minHeight = target.checked
                        ? `${logContainer.offsetHeight + 15}px`
                        : null ;

                    logs.parentNode.classList[exec]('show-logs-always');
                    document.body.classList[exec]('show-logs-always');

                    // üîß Sync both checkboxes to the same state
                    document.querySelectorAll('input[data-action="showLogsAlways"]').forEach(checkbox => {
                        checkbox.checked = target.checked;
                    });
                }
            }

            scrollToTop() {
                this._updateStats('events');
                window.scrollTo({ top: 0, behavior: 'smooth' });
                this.log(`‚ñ≤ Scrolling to top`);
            }

            createCard() {
                const container = document.getElementById('dynamic-container');
                const cardId = `card-${Date.now()}`;

                const card = document.createElement('div');
                card.className = 'card y-fade-in';
                card.id = cardId;
                card.innerHTML = `
                    <h3>Dynamic Card #${this.counters.elements + 1}</h3>
                    <p>This card was created dynamically but works instantly!</p>
                    <button class="btn" data-action="dynamicBtn" data-dynamic="true">Click Me!</button>
                    <button class="btn btn-danger y-btn" data-action="removeElement" data-target="${cardId}">üóëÔ∏è Remove</button>
                `;

                container.appendChild(card);
                this._updateStats('elements');

                this.log(`‚ûï Created card: ${cardId}`);
            }

            createButton() {
                const container = document.getElementById('dynamic-container');
                const buttonId = `btn-${Date.now()}`;

                const wrapper = document.createElement('div');
                wrapper.className = 'card y-fade-in';
                wrapper.id = buttonId;
                wrapper.innerHTML = `
                    <h3>Dynamic Button #${this.counters.elements + 1}</h3>
                    <button class="btn btn-success" data-action="dynamicBtn" data-dynamic="true">I'm Dynamic!</button>
                    <button class="btn btn-warning" data-action="dynamicBtn" data-dynamic="true">Me Too!</button>
                    <button class="btn btn-danger y-btn" data-action="removeElement" data-target="${buttonId}">üóëÔ∏è Remove</button>
                `;

                container.appendChild(wrapper);
                this._updateStats('elements');

                this.log(`‚ûï Created button set: ${buttonId}`);
            }

            clearAll() {
                const container = document.getElementById('dynamic-container');
                const elementsToRemove = container.children.length;

                container.innerHTML = '';
                this.counters.elements = Math.max(0, this.counters.elements - elementsToRemove);
                this.updateStats();

                this.log(`üóëÔ∏è Cleared ${elementsToRemove} dynamic elements from content creator`);
            }

            showAlert(event, target) {
                // Simple notification for SVG button test
                const message = this.autoTargetResolution
                    ? 'üéØ Smart Target Resolution: Active (click worked!)'
                    : 'üîò Smart Target Resolution: Disabled';

                this.showNotification(message);
            }

            addTodo() {
                const input = document.getElementById('todo-input');
                const text = input.value.trim();
                if (!text) return;

                const container = document.getElementById('todo-container');
                const todoId = `todo-${Date.now()}`;

                const todo = document.createElement('div');
                todo.className = 'todo-item y-fade-in';
                todo.id = todoId;
                todo.innerHTML = `
                    <div class="todo-content">
                        <span class="todo-text">${this.escapeHtml(text)}</span>
                        <div class="todo-actions">
                            <button class="btn btn-success y-btn" data-action="completeTodo" data-target="${todoId}">‚úÖ Complete</button>
                            <button class="btn btn-danger y-btn" data-action="deleteTodo" data-target="${todoId}">üóëÔ∏è Delete</button>
                        </div>
                    </div>
                `;

                input.value = '';
                container.appendChild(todo);
                this._updateStats('todos');
                this.saveTodos(); // Save after adding

                this.log(`‚ûï Added todo: ${text}`);
            }

            completeTodo(target) {
                const todoId = target.dataset.target;
                const todo = document.getElementById(todoId);

                if (todo) {
                    todo.classList.toggle('completed');
                    this.saveTodos(); // Save after completing

                    this.log(`‚úÖ Toggled todo: ${todoId}`);
                }
            }

            deleteTodo(target) {
                const todoId = target.dataset.target;
                const todo = document.getElementById(todoId);

                if (todo) {
                    todo.remove();
                    this.counters.todos--;
                    this.updateStats();
                    this.saveTodos(); // Save after deletion

                    this.log(`üóëÔ∏è Deleted todo: ${todoId}`);
                }
            }

            // üíæ localStorage methods for todo persistence
            saveTodos() {
                const todos = [];
                document.querySelectorAll('.todo-item').forEach(todo => {
                    const text = todo.querySelector('.todo-text')?.textContent;
                    const completed = todo.classList.contains('completed');
                    if (text) {
                        todos.push({ text, completed, id: todo.id });
                    }
                });
                localStorage.setItem('ypsilon-todos', JSON.stringify(todos));
            }

            loadTodos() {
                const saved = localStorage.getItem('ypsilon-todos');
                if (saved) {
                    const todos = JSON.parse(saved);
                    const container = document.getElementById('todo-container');

                    todos.forEach(todo => {
                        const todoHtml = `
                            <div class="todo-item ${todo.completed ? 'completed' : ''}" id="${todo.id}">
                                <div class="todo-content">
                                    <span class="todo-text">${this.escapeHtml(todo.text)}</span>
                                    <div class="todo-actions">
                                        <button class="btn btn-success y-btn" data-action="completeTodo" data-target="${todo.id}">‚úÖ Complete</button>
                                        <button class="btn btn-danger y-btn" data-action="deleteTodo" data-target="${todo.id}">üóëÔ∏è Delete</button>
                                    </div>
                                </div>
                            </div>
                        `;
                        container.insertAdjacentHTML('beforeend', todoHtml);
                        this.counters.todos++;
                    });

                    if (todos.length > 0) {
                        this.updateStats();
                        this.log(`üíæ Loaded ${todos.length} todos from localStorage`);
                    }
                }
            }

            switchTab(target) {
                const tabId = target.dataset.tab;

                // Hide all tabs
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.classList.remove('active');
                });

                // Show selected tab
                const tabContent = document.getElementById(tabId);
                const tabButton = document.querySelector(`[data-tab="${tabId}"]`);

                if (tabContent) tabContent.classList.add('active');
                if (tabButton) tabButton.classList.add('active');

                this.log(`üìë Switched to tab: ${tabId}`);
            }

            addTab(target) {
                this.tabCounter++;
                const tabId = `tab${this.tabCounter}`;

                // Add tab button
                const tabsContainer = document.querySelector('.tabs');
                const addButton = tabsContainer.querySelector('[data-action="addTab"]');

                const newTab = document.createElement('button');
                newTab.className = 'tab y-fade-in';
                newTab.dataset.action = 'switchTab';
                newTab.dataset.tab = tabId;
                newTab.textContent = `Tab ${this.tabCounter}`;

                tabsContainer.insertBefore(newTab, addButton);

                // Add tab content
                const tabContent = document.createElement('div');
                tabContent.className = 'tab-content y-fade-in';
                tabContent.id = tabId;
                tabContent.innerHTML = `
                    <h3>Tab ${this.tabCounter} Content</h3>
                    <p>This tab was created dynamically! Event delegation still works.</p>
                    <button class="btn y-btn" data-action="tabAction" data-message="Dynamic tab ${this.tabCounter} button clicked!">Click Me</button>
                    <button class="btn btn-success y-btn" data-action="createElementInTab" data-target="${tabId}">Create Element</button>
                `;

                // Insert after the tabs container
                tabsContainer.parentNode.appendChild(tabContent);
                this.switchTab(newTab);

                this.log(`‚ûï Added dynamic tab: ${tabId}`);
            }

            tabAction(target, event) {
                this.showNotification(target.dataset.message || 'Tab action triggered!');
            }

            dynamicBtn(target) {
                this.log(`üîò Dynamic button: ${target.textContent}`, `Dynamic button clicked: ${target.textContent}`);
            }

            createElementInTab(target) {
                const targetTab = target.dataset.target;
                const tabContent = document.getElementById(targetTab);
                if (!tabContent) return;

                const elementId = `element-${Date.now()}`;
                const element = document.createElement('div');
                const useIndex = this.counters.elements + 1;

                element.id = elementId;
                element.className = 'y-fade-in';
                element.style.cssText = 'margin: 10px 0; padding: 10px; background: #f0f0f0; border-radius: 4px;';
                element.innerHTML = `
                    <p><strong>Dynamic Element #${useIndex}</strong></p>
                    <button class="btn" data-action="dynamicBtn" data-dynamic="true">I work too! <u class="d-none">${useIndex}</u></button>
                    <button class="btn btn-danger y-btn" data-action="removeElement" data-target="${elementId}">Remove</button>
                `;

                tabContent.appendChild(element);
                this._updateStats('elements');

                this.log(`‚ûï Created element in ${targetTab}: ${elementId}`);
            }

            addFormField() {
                // Find the form section by looking for the submit button
                const submitButton = document.querySelector('[data-action="submitForm"]');
                const section = submitButton.closest('.section');

                const fieldId = `field-${Date.now()}`;
                const inputId = `input-${Date.now()}`;
                const formGroup = document.createElement('div');
                formGroup.id = fieldId;
                formGroup.className = 'form-group dynamic-group y-fade-in';
                formGroup.innerHTML = `
                    <label for="${inputId}">Dynamic Field #${this.counters.elements + 1}:</label>
                    <input type="text" id="${inputId}" name="${inputId}" class="form-control y-input" data-action="dynamic-field" placeholder="Dynamic field">
                    <button class="btn btn-danger y-btn" data-action="removeElement" data-target="${fieldId}" style="margin-top: 5px;">Remove Field</button>
                `;

                section.insertBefore(formGroup, submitButton);
                this._updateStats('elements');

                this.log(`‚ûï Added form field: ${fieldId}`);
            }

            submitForm() {
                const inputs = document.querySelectorAll('.y-input');
                const formData = {};

                inputs.forEach((input, idx) => {
                    const action = input.dataset.action;
                    if (action && input.value.trim()) {
                        formData[`${action}-${idx}`] = input.value.trim();
                    }
                });

                this.log(`üì® Form submitted with data: ${JSON.stringify(formData)}`, 'Form submitted successfully!');
            }

            _updateStats() {
                for (const update of arguments) {
                    if (typeof this.counters[update] !== 'undefined') {
                        this.counters[update]++;
                    }
                }
                this.updateStats();
            }

            updateStats() {
                document.getElementById('click-count').textContent = this.counters.clicks;
                document.getElementById('element-count').textContent = this.counters.elements;
                document.getElementById('todo-count').textContent = this.counters.todos;
                document.getElementById('event-count').textContent = this.counters.events;
            }

            updateScrollStats(scrollY, docHeight, windowHeight) {
                document.getElementById('scroll-position').textContent = Math.round(scrollY);
            }

            getMainStatsEl() {
                return document.getElementById('stats-section');
            }

            updateStickyStats(scrollY) {
                const statsSection = this.getMainStatsEl();
                const placeholder = document.getElementById('stats-placeholder');

                // Use placeholder position to determine when to stick/unstick
                const placeholderRect = placeholder.getBoundingClientRect();
                const shouldBeSticky = placeholderRect.top + 130 <= 0;

                if (shouldBeSticky && !statsSection.classList.contains('sticky')) {
                    statsSection.classList.add('sticky');
                    placeholder.classList.add('active');
                    this._updateFadeInClass(statsSection);
                    this.log(`üìå Stats became sticky`);
                } else if (!shouldBeSticky && statsSection.classList.contains('sticky')) {
                    statsSection.classList.remove('sticky');
                    placeholder.classList.remove('active');
                    this._updateFadeInClass(statsSection);
                    this.log(`üìå Stats unstuck with fade-in`);
                }
            }

            _updateFadeInClass(element) {
                element.classList.remove('y-fade-in');
                element.offsetHeight;
                element.classList.add('y-fade-in');
            }

            updateFooterVisibility(scrollY, docHeight, windowHeight) {
                const footer = document.getElementById('footer');
                const threshold = config.threshold.showFooter; // Show when x from bottom

                if (scrollY + windowHeight >= docHeight - threshold) {
                    footer.classList.add('visible');
                } else {
                    footer.classList.remove('visible');
                }
            }

            updateScrollClasses(scrollY, docHeight, windowHeight) {
                const body = document.body;
                const isAtTop = scrollY <= config.threshold.top;
                const isAtBottom = scrollY + windowHeight >= docHeight - config.threshold.bottom;

                // Only change classes when needed to prevent flicker
                if (isAtTop) {
                    // At top: only y-scroll-top
                    if (!body.classList.contains('y-scroll-top')) {
                        body.classList.remove('y-scrolled', 'y-scroll-bottom');
                        body.classList.add('y-scroll-top');
                    }
                } else {
                    // Not at top: remove y-scroll-top, add y-scrolled
                    if (body.classList.contains('y-scroll-top')) {
                        body.classList.remove('y-scroll-top');
                    }
                    if (!body.classList.contains('y-scrolled')) {
                        body.classList.add('y-scrolled');
                    }

                    // Handle bottom class addition/removal
                    if (isAtBottom && !body.classList.contains('y-scroll-bottom')) {
                        body.classList.add('y-scroll-bottom');
                    } else if (!isAtBottom && body.classList.contains('y-scroll-bottom')) {
                        body.classList.remove('y-scroll-bottom');
                    }
                }
            }

            getEventLogContainer() {
                return document.getElementById('event-log');
            }

            removeToast(toastElement) {
                // If toastElement is the close button, get the parent toast div
                const actualToast = toastElement.classList?.contains('toast') ? toastElement : toastElement.closest('.toast');

                if (!actualToast || !actualToast.parentNode) return;

                // Clear the timer if it exists
                if (actualToast.dataset.timerId) {
                    clearTimeout(parseInt(actualToast.dataset.timerId));
                }

                actualToast.remove();

                const notification = document.getElementById('notification');

                // If no toasts left, reset notification container
                if (notification.children.length === 0) {
                    notification.classList.remove('show', 'y-nulled');
                    notification.textContent = this.initialContent || '';
                }
            }

            clearLog() {
                const logContainer = document.getElementById('event-log');
                logContainer.innerHTML = '<div class="log-entry">Event log cleared...</div>';
                this.log('üìã Event log cleared');
            }

            removeElement(target) {
                const elementId = target.dataset.target;
                const element = document.getElementById(elementId);
                if (element) {
                    element.remove();
                    this.counters.elements = Math.max(0, this.counters.elements - 1);
                    this.updateStats();
                    this.log(`üóëÔ∏è Removed element: ${elementId}`);
                }
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            initializePlaceholder() {
                const statsSection = document.getElementById('stats-section');
                const placeholder = document.getElementById('stats-placeholder');
                const assignedListener = document.querySelector('#ypsilon-assigned div');
                const footer = document.getElementById('footer');
                const docBody = document.body

                if (assignedListener) {
                    assignedListener.innerHTML = this.createEventList(this.eventMapping);
                }

                if (footer && !docBody.classList.contains('footer-size-padding')) {
                    docBody.style.paddingBottom = `${footer.offsetHeight}px`
                    docBody.classList.add('footer-size-padding');
                }

                // Set placeholder height immediately on page load
                const initialHeight = statsSection.offsetHeight;
                if (!placeholder.style.height) {
                    placeholder.style.height = initialHeight + 'px';
                    this.log(`üìè Placeholder initialized with height: ${initialHeight}px`);
                }
            }

            updatePlaceholderHeights() {
                const statsSection = document.getElementById('stats-section');
                const placeholder = document.getElementById('stats-placeholder');
                const footer = document.getElementById('footer');
                const docBody = document.body;

                // Recalculate stats section placeholder height
                if (statsSection && placeholder) {
                    const newHeight = statsSection.offsetHeight;
                    const oldHeight = placeholder.style.height;
                    placeholder.style.height = newHeight + 'px';

                    if (oldHeight !== newHeight + 'px') {
                        this.log(`üìè Placeholder height updated: ${oldHeight} ‚Üí ${newHeight}px`);
                    }
                }

                // Recalculate footer padding if needed
                if (footer && docBody.classList.contains('footer-size-padding')) {
                    const newPadding = footer.offsetHeight;
                    const oldPadding = docBody.style.paddingBottom;
                    docBody.style.paddingBottom = `${newPadding}px`;

                    if (oldPadding !== `${newPadding}px`) {
                        this.log(`üìè Footer padding updated: ${oldPadding} ‚Üí ${newPadding}px`);
                    }
                }
            }

            createEventList(data) {
                const ul = document.createElement("ul");
                ul.className = 'assigned-listener-list';

                for (const [scope, events] of Object.entries(data)) {
                    const scopeLi = document.createElement("li");
                    scopeLi.innerHTML = `<span class="selector">${scope}</span>`;

                    const innerUl = document.createElement("ul");

                    for (const event of events) {
                        const li = document.createElement("li");

                        // Handle both string events and object events
                        if (typeof event === 'string') {
                            const handler = `handle${event.charAt(0).toUpperCase() + event.slice(1)}`;
                            li.innerHTML = `<span class="config">${event}, ${handler}</span>`;
                        } else {
                            // Object event with full configuration
                            let { type, handler, ...rest } = event;

                            if (!handler) {
                                handler = `handle${type.charAt(0).toUpperCase() + type.slice(1)}`;
                            }

                            // Show ALL configuration options
                            const restStr = Object.keys(rest).length > 0 ? `, ${JSON.stringify(rest)}` : '';
                            li.innerHTML = `<span class="config">${type}, ${handler}${restStr}</span>`;
                        }

                        innerUl.appendChild(li);
                    }

                    scopeLi.appendChild(innerUl);
                    ul.appendChild(scopeLi);
                }

                return ul.outerHTML;
            }

            log(message, notification) {
                const logContainer = this.getEventLogContainer();
                const entry = document.createElement('div');
                entry.className = 'log-entry y-fade-in y-blink';
                entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                logContainer.appendChild(entry);
                logContainer.scrollTop = logContainer.scrollHeight;

                // Keep only last 50 entries
                const entries = logContainer.querySelectorAll('.log-entry');
                if (entries.length > 50) {
                    entries[0].remove();
                }

                if (notification) {
                    this.showNotification(notification);
                }
            }

            showNotification(message) {
                const notification = document.getElementById('notification');

                if (!notification.classList.contains('y-nulled')) {
                    notification.classList.add('y-nulled');
                    if (!this.initialContent) {
                        this.initialContent = notification.innerHTML;
                    }
                    notification.textContent = '';
                }

                const note = document.createElement('div');
                note.style.cssText = '';
                note.innerHTML = `
                    <span>${this.escapeHtml(message)}</span>
                    <button style="" data-action="removeToast">√ó</button>
                `;

                notification.classList.add('show');
                note.className = 'toast y-fade-in';

                notification.append(note);

                // Individual timer for this specific toast
                const toastTimer = setTimeout(() => {
                    this.removeToast(note);
                }, config.notification.timeout);

                // Store timer on the element for potential manual cancellation
                note.dataset.timerId = toastTimer;
            }

            debugHandler() {
                console.group('üîç YpsilonEventHandler Debug Info');
                console.log('‚öôÔ∏è Configuration:', config);
                console.log('üìä Counters:', this.counters);

                // NEW: Display comprehensive stats from getStats()
                const stats = this.getStats();
                if (stats) {
                    console.log('üìà YpsilonEventHandler Stats:', stats);
                } else {
                    console.log('üìà Stats: Disabled (enable with { enableStats: true })');
                }

                console.log('üó∫Ô∏è Event Handler Map (Multi-Handler System):', this.eventHandlerMap);
                console.log('üìã Element Handlers:', this.elementHandlers);
                console.log('‚è±Ô∏è Throttle Timers:', this.throttleTimers);
                console.log('‚è∞ Debounce Timers:', this.debounceTimers);
                console.log('üéØ Event Listeners Map:', this.eventListeners);
                console.log('üîß Passive Supported:', this.passiveSupported);
                console.log('üë§ User Has Interacted:', this.userHasInteracted);
                console.log('üö´ Passive Events List:', this.passiveEvents);
                console.log('üìà Tab Counter:', this.tabCounter);

                // Show handler mapping breakdown
                console.group('üéØ Handler Mapping Breakdown');
                this.eventHandlerMap.forEach((handlers, eventType) => {
                    console.log(`${eventType}:`, handlers.map(h => ({
                        selector: h.selector,
                        handler: h.handler,
                        element: h.element.tagName || h.element.constructor.name,
                        config: h.config,
                        throttle: h.config?.throttle,
                        debounce: h.config?.debounce,
                        options: h.config?.options
                    })));
                });
                console.groupEnd();

                console.log('üîç Full Handler Object:', this);
                console.groupEnd();

                this.log('üîç Handler debug info logged to console', 'Debug info logged to console!');
            }

            testDispatch() {
                const testData = {
                    timestamp: Date.now(),
                    message: 'Hello from dispatch!',
                    random: Math.floor(Math.random() * 100)
                };
                this.dispatch('testdispatch', testData, document.body);
                this.log('üî• Dispatched custom event with data', `Custom event dispatched: ${JSON.stringify(testData)}`);
            }

            handleTestdispatch(event, target) {
                this._updateStats('events');
                console.log(event)

                this.log(`üî• Custom Event: ${event.type} - Detail: ${JSON.stringify(event.detail)}`);
            }
        }

        // Initialize the SPA with ONE handler for everything!
        let spa = new SPAEventHandler(customEventMap);
        window.spa = spa; // Make globally accessible for debugging

        // Separate listeners for destroy/recreate buttons (these need to survive destruction)
        const destroyBtn = document.getElementById('destroy-btn');
        const recreateBtn = document.getElementById('recreate-btn');
        const handlerStatus = document.getElementById('handler-status');

        // Persistent handler for smart target resolution toggle (survives destroy/recreate)
        const autoTargetToggle = document.getElementById('auto-target-toggle');

        autoTargetToggle.addEventListener('change', (event) => {
            const enabled = event.target.checked;

            // Get current counters to preserve them
            const currentCounters = { ...spa.counters };

            // Destroy current handler
            spa.destroy();

            // Create new instance with toggled setting
            const toggleConfig = {
                enableStats: true,
                autoTargetResolution: enabled
            };

            spa = new SPAEventHandler(undefined, undefined, { ...config, ...toggleConfig });
            window.spa = spa;

            // Preserve the counters from the old instance
            spa.counters = currentCounters;
            spa.updateStats();

            const status = enabled ? 'ENABLED ‚úÖ' : 'DISABLED ‚ùå';

            spa.showNotification(`üéØ Smart Target Resolution ${status}`);
        });

        destroyBtn.addEventListener('click', () => {
            if (spa.getMainStatsEl()) spa.getMainStatsEl().classList.remove('sticky');

            spa.destroy();

            // Update UI
            destroyBtn.disabled = true;
            recreateBtn.disabled = false;
            handlerStatus.textContent = 'DESTROYED';
            handlerStatus.style.color = '#dc3545';

            console.log('üîç Destroyed Handler Object:', spa);
            spa.log('üíÄ Handler DESTROYED - Listeners removed! Try clicking/scrolling/typing now!', 'Handler destroyed!');
        });

        recreateBtn.addEventListener('click', () => {
            if (spa.getMainStatsEl()) spa.getMainStatsEl().classList.add('sticky');

            spa = new SPAEventHandler();
            window.spa = spa;

            // Update UI
            destroyBtn.disabled = false;
            recreateBtn.disabled = true;
            handlerStatus.textContent = 'ACTIVE';
            handlerStatus.style.color = '#28a745';

            console.log('üîç Recreated Handler Object:', spa);
            spa.log('üîÑ Handler RECREATED - All events are working again!', 'Handler recreated!');
        });

        // Initial log
        spa.log('üöÄ SPA initialized with ONE body listener handling ALL events!');
        spa.log('‚ú® Try creating, deleting, and interacting with dynamic elements');
        spa.log('üéØ Notice how everything works without adding new listeners!');
    </script>
</body>
</html>
