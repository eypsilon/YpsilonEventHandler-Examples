<!DOCTYPE html>
<!--
🎯 STRESSMACHER S-800 PERFORMANCE BENCHMARKING TOOL 🎯
Revolutionary performance testing tool for YpsilonEventHandler!
Contributors: Claude, ChatGPT, Grok, DeepSeek, Gemini

This tool demonstrates YpsilonEventHandler's revolutionary advantages:
✅ O(1) vs O(n) performance comparison (Manual vs Ypsilon)
✅ DOM Event Scoping System with multiple handlers per event type
✅ Clean stress scheduler with predictable timing
✅ Comprehensive stress logs and performance metrics
✅ Epic endurance testing capabilities
✅ Real-time performance monitoring

The StressMacherUltimate class provides clean, predictable timing
for stress testing both manual event listeners and YpsilonEventHandler.
-->
<html lang="en">
<head><meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StressMacher S-800, Serial event killer ~ YpsilonEventHandler</title>
    <link rel="stylesheet" type="text/css" href="./assets/main.css">
    <style>
        :root {
            --primary: #4a6fa5;
            --primary-hover: #7ea6e2;
            --secondary: #166088;
            --light: #f8f9fa;
            --dark: #343a40;
            --success: #28a745;
            --danger: #dc3545;
            --gap-size: 10px 14px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.5;
            color: #333;
            max-width: 1080px;
            margin: 0 auto;
            padding: 20px 20px 0;
            background-color: #e9e9e9;
        }

        .container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
        }

        .header {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
            position: relative;
        }

        .mode-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 0;
            padding: 10px;
            background: linear-gradient(135deg, #a7c0e494 0%, #5f10ac87 100%);
        }

        .mode-selector button {
            flex: 1;
        }

        .control-panel {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 2fr));
            gap: 30px;
        }

        .control-panel .control-group-wrapper {
            min-width: 164px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            position: relative;
        }

        .control-group.extra-configs {
            padding: 15px;
            min-width: 280px;
            position: absolute;
            top: 40px;
            right: 0;
            z-index: 1;
            gap: 12px;
            background: #fff;
            box-shadow: 0 0 10px 2px rgba(97, 102, 123, 0.6);
        }

        .control-group.extra-configs select {
            margin-top: 8px;
            padding: 0;
        }

        .control-group.extra-configs select option {
            padding: 12px;
        }

        .control-group.extra-configs .input-checkbox {
            position: relative;
        }

        .control-group.extra-configs .input-checkbox label {
            padding: 5px 10px;
            border: 1px solid #ddd;
            cursor: pointer;
        }

        .control-group.extra-configs .input-checkbox input {
            width: auto;
            position: absolute;
            right: 10px;
            cursor: pointer;
        }

        .control-group.extra-configs .timeout-range .form-el-group {
            margin-top: 8px;
        }

        h1,
        h2,
        h3,
        h4,
        h5 {
            margin-top: 0;
            line-height: 1;
        }

        h1 {
            font-size: 1.2rem;
            display: flex;
            justify-content: space-between;
        }

        label,
        .label {
            font-weight: 600;
            font-size: 0.9rem;
            white-space: nowrap;
        }

        select,
        input,
        button {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.9rem;
        }

        select[disabled],
        input[disabled],
        button[disabled] {
            opacity: 0.4;
            pointer-events: none;
        }

        select {
            width: 100%;
        }

        button {
            background-color: var(--primary);
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
        }

        button.active,
        button:hover {
            background-color: var(--secondary);
        }

        button.danger {
            background-color: var(--danger);
        }

        button.success {
            background-color: var(--success);
        }

        button.active {
            background-color: var(--secondary);
            box-shadow: inset 0 0 0 2px white;
        }

        ::placeholder {
            color: #b1a1a1;
            opacity: 0.5;
        }

        .test-area,
        .test-area h3 {
            transition: all 0.5s ease-in-out;
        }

        .test-area h3 {
            margin-bottom: 8px;
        }

        .info-container,
        .verify-listeners,
        .test-area {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            min-height: 200px;
        }

        .info-container.finished,
        .verify-listeners.finished,
        .test-area.finished {
            box-shadow: 0 2px 10px 2px rgba(88, 237, 8, 0.7);
        }

        .info-container.finished h3,
        .verify-listeners.finished h3,
        .test-area.finished h3 {
            color: var(--success);
            text-shadow: 2px 2px #f4433663, -2px -2px #364cf463;
        }

        .info-container.running,
        .verify-listeners.running,
        .test-area.running {
            box-shadow: 0 2px 10px 2px rgba(226, 35, 9, 0.5);
        }

        .elements-container {
            border: 1px dashed #eee;
            padding: 5px;
            border-radius: 4px;
            min-height: 128px;
            max-height: 40vh;
            overflow: auto;
            overflow-y: scroll;
        }

        .verify-listeners h3 {
            margin-bottom: 10px;
        }

        .info-container h3,
        .info-container h4 {
            margin-bottom: 10px;
        }

        .info-container>p {
            margin-bottom: 10px;
        }

        .info-container .main-info {
            padding: 15px;
            line-height: 1.5;
            font-size: 14px;
            background: #f1f1f1;
            box-shadow: 0 0px 4px 2px #cfe5eef7;
        }

        .info-container .main-info:not(:last-of-type) {
            margin-bottom: 16px;
        }

        .info-container .main-info p:not(:last-of-type) {
            margin-bottom: 10px;
        }

        pre {
            font-size: 14px;
        }

        .clear-log {
            position: fixed;
            bottom: 115px;
            right: 20px;
            background: #f44336;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            z-index: 1001;
        }

        .log {
            position: fixed;
            bottom: 15px;
            right: 15px;
            width: 100%;
            max-width: 400px;
            height: 90px;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 15px;
            padding: 5px 10px;
            overflow-y: scroll;
            border: 2px solid #00ff00;
            z-index: 9999;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            background: #1d1c1cd5;
            transition: all 0.15s 1s ease-in-out;
        }

        .log:focus,
        .log:hover {
            max-width: 80%;
            height: 440px;
            background: #1d1c1cf7;
            overscroll-behavior: contain;
        }

        .log:focus span.method-note,
        .log:hover span.method-note,
        .log:focus span.log-data-last-col,
        .log:hover span.log-data-last-col {
            max-width: unset;
        }

        .clear-log,
        .log {
            transition: all 0.5s 0.8s ease-in-out;
            opacity: 1;
        }

        body:not(.elements-generated) .clear-log,
        body:not(.elements-generated) .log {
            opacity: 0;
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 2px 0;
            display: flex;
            align-items: center;
            min-height: 20px;
            line-height: 1.4;
        }

        .log-entry:not(:last-of-type) {
            border-bottom: 1px solid rgba(0, 255, 170, 0.1);
        }

        .log-entry span {
            padding: 0 6px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .log-date {
            padding: 0;
            min-width: 92px;
            font-weight: bold;
        }

        .stats-panel {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            max-width: 50%;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
        }

        /* Performance Indicators */
        .performance-indicator {
            height: 12px;
            background: linear-gradient(90deg, #28a745 0%, #ffc107 50%, #dc3545 100%);
            border-radius: 6px;
            position: relative;
            overflow: hidden;
        }

        .performance-bar {
            height: 100%;
            width: 0%;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 6px;
            transition: width 0.3s ease;
            position: relative;
        }

        .performance-bar::after {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 2px;
            height: 100%;
            background: #333;
            border-radius: 1px;
        }

        .stat-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 4px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: var(--primary);
        }

        .stat-label {
            font-size: 0.9rem;
            color: #666;
        }

        .hidden {
            display: none;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.7);
            }

            50% {
                transform: scale(1.05);
                box-shadow: 0 0 0 10px rgba(220, 53, 69, 0);
            }

            100% {
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(220, 53, 69, 0);
            }
        }

        .elements-container {
            border: 1px dashed #eee;
            padding: 5px;
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            flex-flow: wrap;
            align-items: center;
            gap: var(--gap-size);
            scroll-behavior: smooth;
            line-height: 1;
        }

        .elements-container>div {
            flex: 1 10%;
            min-width: fit-content;
            white-space: nowrap;
            line-height: 1;
        }

        .elements-container>div label {
            padding: 0px 14px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            cursor: pointer;
            box-shadow: 0 0 6px 1px rgba(48, 80, 61, 0.3);
            line-height: 1;
            overflow: hidden;
        }

        .elements-container>div label input {
            margin: 0 8px 0 0;
        }

        .elements-container>div div button,
        .elements-container>div div input[type="text"] {
            width: 100%;
        }

        .form-el-group {
            display: flex;
            align-items: center;
        }

        .form-el-group label {
            width: 100%;
            align-items: center;
        }

        .form-el-group input {
            width: 100%;
        }

        .test-checkbox-wrap {
            background: #efe7ddbd;
        }

        .test-checkbox-radio {
            background: #e6f4f4ed;
        }

        .test-checkbox-radio input[type="radio"]:checked+span {
            color: #f90707;
        }

        .control-group>label,
        .control-group>.label,
        .elements-container label,
        .elements-container .label,
        .test-button,
        .test-input,
        .test-checkbox,
        .test-select {
            padding: 0px 0;
            max-height: 36px;
        }

        .test-button,
        .test-input,
        .test-checkbox {
            white-space: nowrap;
            outline: 0;
        }

        .test-button,
        .test-input,
        .test-select {
            padding-left: 8px;
            padding-right: 8px;
            flex: 1 10%;
        }

        .test-button {
            height: 38px;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .test-button:focus,
        .test-button:hover,
        .test-button:active {
            color: #fa3131;
            background: var(--primary-hover);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .test-select,
        .test-input {
            border: 1px solid #ddd;
            border-radius: 4px;
            height: 38px;
        }

        .test-select:focus,
        .test-input:focus {
            border-color: var(--danger);
        }

        .test-checkbox {
            accent-color: var(--danger);
        }

        .test-checkbox:checked+span {
            color: var(--danger);
            background: rgba(200, 244, 218, 0.8);
            box-shadow: 0 0 50px 26px rgba(208, 248, 224, 0.9);
        }

        .stat-card[data-better="manual"] {
            box-shadow: 0 0 0 2px #dc3545;
            background: rgba(220, 53, 69, 0.1);
        }

        .stat-card[data-better="ypsilon"] {
            box-shadow: 0 0 0 2px #28a745;
            background: rgba(40, 167, 69, 0.1);
        }

        .src-nav {
            margin: 3rem 0;
        }

        .src-nav hr {
            margin: 8px 0;
        }

        .nav-container {
            margin: 0;
        }

        .extras-area {
            display: flex;
            gap: 10px;
        }

        .extras-area .stats-panel {
            width: 100%;
        }

        .extras-area .config-panel {
            background: white;
            padding: 0px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 50%;
        }

        .extras-area .config-panel pre {
            margin: 0;
            min-height: 100%;
            max-height: 200px;
        }

        .panel-wrapper {
            display: flex;
            flex-direction: column;
            width: 100%;
            height: 100%;
        }

        .pan-inner {
            background: #f8f9fa;
            flex: 1;
        }

        pre.pan-inner {
            padding: 20px 15px;
        }

        div.pan-inner {
            padding: 8px;
            width: 100%;
            position: absolute;
            bottom: 0;
            opacity: 1;
            border-top: 1px solid #d1d1d1;
            background: #e8f5e8;
            border-radius: 0 0 4px 4px;
            font-size: 0.9em;
            text-align: center;
            transition: all 0.25s ease-in-out;
        }

        .panel-wrapper:hover div.pan-inner {
            bottom: -25px;
            opacity: 0;
        }

        /* S-800 Avatar */
        .serminator {
            margin-left: -25px;
            width: 50px;
            position: absolute;
            top: 8px;
            left: 50%;
            font-size: 38px;
            text-align: center;
            user-select: none;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>
                <span>StressMacher S-800</span>
                <span class="serminator">🤖</span>
                <span><a href="./index.html" title="Back to index" style="text-decoration: none;">«</a> Serial Event Killer</span>
            </h1>
            <div class="mode-selector">
                <button data-action="setMode" data-mode="manual" class="active">Manual Listeners</button>
                <button data-action="setMode" data-mode="ypsilon">Ypsilon Listeners</button>
            </div>
            <div class="control-panel">
                <!-- Elements to create -->
                <div class="control-group">
                    <span class="label">Element Type</span>
                    <div class="form-el-group">
                        <label for="createTotalButton">Button</label>
                        <input type="number"
                            data-action="setTestConfig"
                            data-key="createTotalButton"
                            data-group
                            id="createTotalButton" min="1" max="100000" value="1000">
                    </div>
                    <div class="form-el-group">
                        <label for="createTotalText">Text</label>
                        <input type="number"
                            data-action="setTestConfig"
                            data-key="createTotalText"
                            data-group
                            id="createTotalText" min="1" max="100000" value="1000">
                    </div>
                </div>
                <!-- Checkbox/Radios to create -->
                <div class="control-group">
                    <span class="label">~</span>
                    <div class="form-el-group">
                        <label for="createTotalCheckbox">Checkbox</label>
                        <input type="number"
                            data-action="setTestConfig"
                            data-key="createTotalCheckbox"
                            data-group
                            id="createTotalCheckbox" min="1" max="100000" value="1000">
                    </div>
                    <div class="form-el-group">
                        <label for="createTotalRadiobox">Radiobox</label>
                        <input type="number"
                            data-action="setTestConfig"
                            data-key="createTotalRadiobox"
                            data-group
                            id="createTotalRadiobox" min="1" max="100000" value="1000">
                    </div>
                </div>
                <!-- Select to create, sync inputs -->
                <div class="control-group">
                    <span class="label">~</span>
                    <div class="form-el-group">
                        <label for="createTotalSelect">Select</label>
                        <input type="number"
                            data-action="setTestConfig"
                            data-key="createTotalSelect"
                            data-group
                            id="createTotalSelect" min="1" max="100000" value="1000">
                    </div>
                    <div class="form-el-group">
                        <label for="createTotalSelect">Sync</label>
                        <input type="number"
                            data-action="setTestConfig"
                            data-key="syncAllElements"
                            id="syncAllElements" min="1" max="100000" value="">
                    </div>
                </div>
                <!-- More options -->
                <div class="control-group">
                    <button data-action="toggleConfig" data-text="⚙️ Less" style="background: darkcyan">⚙️ More</button>
                    <div class="form-el-group">
                        <label for="logLevel">Log Level</label>
                        <select data-action="setLogLevel" id="logLevel">
                            <option value="minimal" selected>⚡ Minimal (Fast)</option>
                            <option value="summary">📊 Summary (Performance)</option>
                            <option value="verbose">🔍 Verbose (Detailed)</option>
                        </select>
                    </div>

                    <div class="control-group extra-configs hidden">
                        <!-- Depth -->
                        <div class="form-el-group" title="Nesting Depth (0 = flat)">
                            <label for="nestingDepth">Depth</label>
                            <input type="number"
                                data-action="setTestConfig"
                                data-key="nestingDepth"
                                id="nestingDepth" min="0" max="1000" value="0">
                        </div>
                        <!-- Auto focus -->
                        <div class="form-el-group input-checkbox"
                            title="Enable, that elements get additionally focused while stress tests. Focus forces the browser to jump to the focused element.">
                            <label for="formElFocus">Auto focus</label>
                            <input type="checkbox"
                                data-action="setTestConfig"
                                data-key="formElFocus" id="formElFocus">
                        </div>
                        <!-- Once Only -->
                        <div class="form-el-group input-checkbox"
                            title="This option makes sure, that elements are used once by removing the data-action attribute.">
                            <label for="onceOnly">Once Only</label>
                            <input type="checkbox"
                                data-action="setTestConfig"
                                data-key="onceOnly"
                                id="onceOnly"
                                title="Remove data-action after first trigger to ensure each element is touched only once">
                        </div>
                        <!-- Timeout range -->
                        <!-- <div class="form-not-group timeout-range" title="A number between the given range for artificial breaks">
                            <span class="label">Timeout range</span>
                            <div class="form-el-group input-number">
                                <label for="actionTimeRangeMin">Min</label>
                                <input type="number"
                                    data-action="updateTimerConfig"
                                    id="actionTimeRangeMin" min="0" max="10000" value="0">
                            </div>
                            <div class="form-el-group input-number">
                                <label for="actionTimeRangeMax">Max</label>
                                <input type="number"
                                    data-action="updateTimerConfig"
                                    id="actionTimeRangeMax" min="50" max="10000" value="0">
                            </div>
                        </div> -->
                        <hr />
                        <div class="form-not-group stats-config">
                            <div class="form-el-group">
                                <button data-action="resetStats" style="margin-bottom: 8px; width: 100%;background: #6c757d; color: white; padding: 10px 12px; border: none; border-radius: 4px; font-size: 0.8em; cursor: pointer;">📊 Reset Stats</button>
                            </div>
                            <div class="form-el-group">
                                <button data-action="viewStressLogs" style="width: 100%;background: #17a2b8; color: white; padding: 10px 12px; margin-right: 5px; border: none; border-radius: 4px; font-size: 0.8em; cursor: pointer;">📊 View Stress Logs</button>
                                <button data-action="clearLocalStorage" style="padding: 10px 12px; white-space: nowrap; background: #f0584d; border: none; cursor: pointer; color: #fffafa;">&times; Clear</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="control-panel" style="margin-top: .5rem; display: flex; flex-flow: wrap; gap: 2rem;">
                <div class="control-group-wrapper">
                    <div class="control-group">
                        <span class="label">Actions</span>
                        <button data-action="generateElements" class="stress-test-btn">Create elements</button>
                        <button data-action="clearElements" class="stress-test-btn" disabled
                            style="background: #dc3545; font-weight: bold;">Remove elements</button>
                        <div class="element-counter" style="margin-top: 2px; padding: 4px 8px; background: #f5f5f5; border-radius: 4px; font-size: 0.9em; color: #666;">
                            Elements: <span id="elementCount">0</span>
                        </div>
                    </div>
                </div>

                <div class="control-group-wrapper">
                    <div class="control-group stress-test-group">
                        <span class="label">Stress Test</span>
                        <button data-action="stressTest" class="stress-test-btn" disabled style="background: #ffeb3b; color:#666; font-weight: bold;" data-text="🔥 » STRESSING 🔥">🔥 STRESSTEST 🔥</button>
                        <button id="abortTestButton" data-action="abortTest" style="background: #f44336; font-weight: bold; display: none;">ABORT TEST</button>
                    </div>
                </div>

                <div class="control-group-wrapper" style="flex: 1;">
                    <div class="control-group" style="height: 100%; display: flex; flex-direction: column;">
                        <span class="label">Crossing the Lines</span>
                        <p style="margin: 0; flex: 1;">Experience the ultimate difference between instant fresh and instant death. Once Manual listeners are bound, new HTML content dies on sight. YpsilonEventHandler's magic on the other hand doesn't care, it just works!</p>
                        <button data-action="infinityTest" class="stress-test-btn" disabled
                        title="This button duplicates all existing elements in the test area."
                        style="background: #e91e63; font-weight: bold;" data-text="∞ INFINITING ∞">∞ INFINITY TEST ∞</button>
                    </div>
                </div>
            </div>
        </header>

        <div class="test-area">
            <div id="manualTest" class="test-section">
                <h3 style="display:flex;align-items:center;justify-content:space-between;">
                    <span>Manual Event Listeners</span>
                </h3>
                <div id="manualElements" class="elements-container">Stress is pending... 👀</div>
                <small style="color: #555;font-size: 13px"></small>
                <p style="margin:6px 0 0;color: #555;font-size: 13px"><small>(O(n) Performance - Each element = 1 listener)</small></p>
            </div>
            <div id="ypsilonTest" class="test-section hidden">
                <h3 style="display:flex;align-items:center;justify-content:space-between;">
                    <span>YpsilonEventHandlers</span>
                </h3>
                <div id="ypsilonElements" class="elements-container"></div>
                <p style="margin:6px 0 0;color: #555;font-size: 13px"><small>(O(1) Performance - Only 3 listeners total)</small></p>
            </div>
        </div>

        <div class="extras-area">
            <div class="stats-panel">
                <h2 style="margin-bottom: 15px;">🤖 Performance Metrics</h2>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="eventCount">0</div>
                        <div class="stat-label">Total Events</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="eventsPerSecond">0</div>
                        <div class="stat-label">Events/Second</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="peakEventsPerSecond">0</div>
                        <div class="stat-label">Peak Events/Sec</div>
                    </div>
                </div>

                <!-- Real-time Performance Indicator -->
                <div style="margin-top: 15px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                        <span style="font-size: 0.9rem; font-weight: 600;">Event Throughput</span>
                        <span style="font-size: 0.8rem; color: #666;" id="throughputStatus">Ready</span>
                    </div>
                    <div class="performance-indicator">
                        <div class="performance-bar" id="performanceBar"></div>
                    </div>
                </div>

                <!-- Benchmark Progress -->
                <div style="margin: 15px 0 0; padding: 10px 10px 0; background: #f6f7f8; border-radius: 6px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                        <span style="font-size: 0.9rem; font-weight: 600;">🎯 Benchmark Progress</span>
                        <span style="font-size: 0.8rem;" id="benchmarkProgress">0 / calculating...</span>
                    </div>
                    <div style="height: 8px; background: #e9ecef; border-radius: 4px; overflow: hidden;">
                        <div style="height: 100%; width: 0%; background: linear-gradient(90deg, #28a745, #17a2b8); transition: width 0.3s ease;" id="benchmarkBar"></div>
                    </div>
                    <div style="font-size: 0.75rem; color: #666; margin-top: 5px; text-align: center;" id="dynamicTargetInfo">
                        Target: calculating...
                    </div>
                    <!-- BEAST MODE TIMER (Moved here, smaller) -->
                    <div style="margin-top: 2px; padding-bottom: 4px; text-align: center;">
                        <span style="font-size: 12px; color: #999;">🔥 Beast Mode Timer: </span>
                        <span id="stressTestDuration" style="font-size: 12px; color: #999;">00:00</span>
                    </div>
                </div>

            </div>
            <div class="config-panel">
                <div class="panel-wrapper" style="position:relative;">
                    <pre class="pan-inner" id="currentConfiguration"></pre>
                    <div class="pan-inner">
                        <strong>🎯 Efficiency:</strong> 3 listeners handle 5000+ elements<br>
                        <span style="color: #666;">O(1) delegation vs O(n) manual binding</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="verify-listeners">
            <h3>🔍 Verify Assigned Listeners (Dev Console)</h3>
            <p><em>Run this snippet to confirm the configured listeners on this page.</em></p>
            <pre style="min-height:unset;"><b
                style="color:#888;user-select:none;margin-right:8px;">⚠️ For Chrome, type first <span class="flip-emoji">⚠️</span></b><code>allow pasting</code></pre>
<pre class="auto-height" contenteditable="true">[
  window, document, ...document.querySelectorAll('*')
].filter(el => {
    const listeners = getEventListeners(el);
    return listeners && Object.keys(listeners).length > 0;
}).forEach((el, i) => {
    const elementName = el === window
        ? 'window'
        : el === document ? 'document' : el.tagName.toLowerCase() + (el.id ? '#' + el.id : '') + (el.className ? '.' + el.className.split(' ').join('.') : '');
    const listeners = getEventListeners(el);
    console.log(`${i+1}. ${elementName}:\n`, listeners);
})</pre>
            <pre style="font-size: 14px">💥 <strong>Want to expose website bloat?</strong> Check our <a href="https://github.com/eypsilon/YpsilonEventHandler-Examples?tab=readme-ov-file#-real-world-listener-analysis">README.md</a> for the ultimate real-world listener analyzer that reveals the hidden performance crisis on major sites!</pre>
        </div>

        <div class="info-container">
            <h3>🍥 What in the hell is a "StressMacher"?</h3>
            <p>Well, we're glad that you ask!</p>

            <section class="main-info manual-listener-info">
                <p>The StressMacher lives up to its name and reputation. Just create form elements and let it run wild. It simulates realistic form interactions to see how the system reacts to a flood of events triggered by user interactions. You can use the <code>⚙️ More</code> menu to configure the behavior further. It's not groundbreaking - no MemoryMonitoring bells and whistles - it's purely about flooding input elements with realistic interactions to see what works and what doesn't.</p>
                <p><b>The Infinity Option:</b> It copies the form elements as raw HTML, basically the way such elements usually get injected into websites. When Manual listeners are active, Infinity becomes the Extinction Entity - no newly added elements will work, nada, dead on arrival. But then try YpsilonEventHandler, the Resurrector of Event Delegation, the <b>Super Delegator</b> - the only real one with wings!</p>
            </section>

            <section class="main-info manual-listener-info">
                <h4>Manual Event Listeners (Traditional Approach)</h4>
                <p>In this mode, every interactive element gets its own dedicated event listener. Each new button, input, and checkbox adds another listener to memory - the classical O(n) performance trap. Watch how your browser staggers under the weight of thousands of individual listeners. The <b>Infinity Option</b> becomes your digital nemesis here: click it and witness the spectacular collapse as newly injected elements land dead on arrival, completely unresponsive.</p>
            </section>

            <section class="main-info ypsilon-listener-info">
                <h4>YpsilonEventHandler (Revolutionary O(1) Approach)</h4>
                <p>The revolutionary DOM Event Scoping System uses only 3 universal listeners regardless of element count. Through mathematical DOM distance caching and closest-match resolution, it maintains constant O(1) performance even with infinite elements. The <b>Infinity Option</b> transforms from destroyer to creator: watch as dynamically injected elements spring to life instantly, fully interactive. This is the <b>Super Delegator</b> with wings - the Resurrector of Event Delegation!</p>
            </section>
        </div>

        <div class="nav-container">
            <!-- Navigation to other examples -->
            <nav class="main-nav">
                <div>
                    <a href="./index.html" class="btn-primary">Start</a>
                    <a href="./basic-example.html" class="btn-secondary">Basic Example</a>
                    <a href="./reactive-y.html" class="btn-danger">Reactive Demo</a>
                    <a href="./single-listener-multiple-actions.html" class="btn-purple">Single Listener</a>
                    <a href="./spa.html" class="btn-success">SPA Demo</a>
                    <a href="./stressmacher.deepseek.html" class="btn-teal btn-disabled">StressMacher S-800</a>
                    <a href="./multi-handler-demo.html" class="btn-warning">Multi-Handler System</a>
                    <a href="https://github.com/eypsilon/YpsilonEventHandler" class="btn-dark">GitHub</a>
                </div>
            </nav>
        </div>

    </div>

    <button class="clear-log" data-action="clearLog">Clear Log</button>
    <div class="log" id="eventLog"></div>

    <!-- Stress Logs Modal -->
    <div id="stressLogsModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgb(29 27 27 / 61%); z-index: 10000;">
        <div style="position: relative; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; border-radius: 8px; max-width: 90vw; max-height: 90vh; overflow: hidden; box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
            <div style="padding: 20px; border-bottom: 1px solid #eee; display: flex; justify-content: space-between; align-items: center;">
                <h2 style="margin: 0;">📊 Stress Test Logs</h2>
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <button data-action="stressLogToConsole" style="background: none; border: none; font-size: 18px; cursor: pointer; color: #999;">console.log</button>
                    <button data-action="closeStressLogs" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #999;">&times;</button>
                </div>
            </div>
            <div style="padding: 0; overflow: auto; max-height: 80vh;">
                <div id="stressLogsContent">
                    <p>Loading stress logs...</p>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/ypsilon-event-handler@v1.8.2/ypsilon-event-handler.min.js"></script>

    <script>
        // Init mode
        let currentMode = 'manual';

        // Write and use methods from anywhere, implement later, if
        // you want, or not, IDK, your APP, your choice.
        const benchmarkHandler = {
            setLogLevel: (target, event) => {
                loggingSystem.setLogLevel(target.value);
            },

            // updateTimingThreshold: DISABLED - Formula being calibrated in script
            // Once perfect formula is found, this will become a simple min/max range control
            toggleConfig: (target, event) => {
                const configPanel = document.querySelector('.control-group.extra-configs');
                if (configPanel) {
                    const currentLabel = target.textContent;
                    const newLabel = target.dataset.text;
                    configPanel.classList.toggle('hidden');
                    target.classList.toggle('active');
                    if (currentLabel && newLabel) {
                        target.dataset.text = currentLabel;
                        target.textContent = newLabel;
                    }
                }
            },
        };

        // Config BenchMarkHandler (the whole example needs event handler to trigger stuff, too)
        const benchmarkSetup = {
            eventMapping: {
                'header': ['click', 'input', 'change'],
                '.clear-log': ['click'],
                '#stressLogsModal': ['click'],
            },
            config: {
                methods: benchmarkHandler,
                methodsFirst: false,
                enableGlobalFallback: true,
                enableConfigValidation: false,
                autoTargetResolution: true,
            },
        }

        // Config the StressMacher
        const benchmarkConfig = {
            test: {
                formElFocus: false,
                onceOnly: false,
                eventTypes: ['click', 'input', 'change'],
                nestingDepth: 0,
                createTotalButton: 0,
                createTotalText: 0,
                createTotalCheckbox: 0,
                createTotalRadiobox: 0,
                createTotalSelect: 0,
                maxEventsPerSecond: 1000, // Throttle if needed
                interactionPattern: 'random' // 'random' or 'sequential'
            },
            simulateUsage: {
                enabled: true,
                timeout: {
                    min: 50,
                    max: 75,
                },
            },
        };

        // Test state management
        let testState = {
            isRunning: false,
            currentTest: null,
            abortController: null
        };

        // DYNAMIC EVENT COUNT CALCULATOR
        function calculateExpectedTotalEvents() {
            const config = benchmarkConfig.test;
            const totalElements = parseInt(config.createTotalButton) +
                                parseInt(config.createTotalText) +
                                parseInt(config.createTotalCheckbox) +
                                parseInt(config.createTotalRadiobox) +
                                parseInt(config.createTotalSelect);

            // Each element type generates different events (based on actual test data):
            // Buttons: 1 event (click)
            // Text: Character-based events (each typed character = 1 input event)
            // Checkbox: 1 event (change)
            // Radio: 1 event (change)
            // Select: 1 event (change)

            // Calculate average word length from testTexts array
            const testTexts = ['Hello', 'World', 'Test', 'Performance', 'Monster', 'YpsilonEventHandler'];
            const avgWordLength = testTexts.reduce((sum, word) => sum + word.length, 0) / testTexts.length;
            // Average = (5+5+4+11+7+20)/6 = 52/6 = 8.67 characters per text input

            const buttonEvents = parseInt(config.createTotalButton) * 1;
            const textEvents = parseInt(config.createTotalText) * Math.round(avgWordLength); // Character-based calculation
            const checkboxEvents = parseInt(config.createTotalCheckbox) * 1;
            const radioEvents = parseInt(config.createTotalRadiobox) * 1;
            const selectEvents = parseInt(config.createTotalSelect) * 1;

            return {
                totalElements,
                expectedEvents: buttonEvents + textEvents + checkboxEvents + radioEvents + selectEvents,
                breakdown: {
                    buttons: buttonEvents,
                    text: textEvents,
                    checkbox: checkboxEvents,
                    radio: radioEvents,
                    select: selectEvents
                }
            };
        }

        // CALCULATE ACTUAL EVENTS (AFTER TEST COMPLETION)
        function calculateActualExpectedEvents() {
            const config = benchmarkConfig.test;

            // Use actual typed characters instead of estimated average
            const buttonEvents = parseInt(config.createTotalButton) * 1;
            const textEvents = stats.actualCharactersTyped; // Actual characters typed
            const checkboxEvents = parseInt(config.createTotalCheckbox) * 1;
            const radioEvents = parseInt(config.createTotalRadiobox) * 1;
            const selectEvents = parseInt(config.createTotalSelect) * 1;

            return {
                totalElements: parseInt(config.createTotalButton) + parseInt(config.createTotalText) +
                             parseInt(config.createTotalCheckbox) + parseInt(config.createTotalRadiobox) +
                             parseInt(config.createTotalSelect),
                expectedEvents: buttonEvents + textEvents + checkboxEvents + radioEvents + selectEvents,
                actualCharacters: stats.actualCharactersTyped,
                textInputs: stats.textInputCount,
                breakdown: {
                    buttons: buttonEvents,
                    text: textEvents,
                    checkbox: checkboxEvents,
                    radio: radioEvents,
                    select: selectEvents
                }
            };
        }

        // UPDATE DYNAMIC TARGET INFO
        function updateDynamicTargetInfo() {
            const expected = calculateExpectedTotalEvents();
            const targetInfo = document.getElementById('dynamicTargetInfo');
            if (targetInfo) {
                const stressThreshold = 2500;
                const stressPercentage = Math.round((expected.expectedEvents / stressThreshold) * 100);
                targetInfo.textContent = `Target: ${expected.totalElements} elements ≈ ${expected.expectedEvents} events (avg ${Math.round(expected.expectedEvents/expected.totalElements*10)/10}/element)`;
                // Color coding based on stress level
                if (expected.expectedEvents >= stressThreshold) {
                    targetInfo.style.color = '#dc3545'; // Red - high stress
                } else if (expected.expectedEvents >= 1500) {
                    targetInfo.style.color = '#ff6b35'; // Orange - medium stress
                } else {
                    targetInfo.style.color = '#666'; // Default gray
                }
            }
        }

        // CLEAN STRESS SCHEDULER (Surgical Reset)
        // Simple, predictable timing using ONLY timeout config
        class StressMacherUltimate {
            constructor(elements, options = {}) {
                this.elements = elements.slice();
                this.baseDelay = options.baseDelay || 350;
                this.maxJitter = options.maxJitter || 500;
                this.abortSignal = options.abortSignal || null;
                this.onElement = options.onElement || ((el) => el.click());
                this.onProgress = options.onProgress || (() => {});
                this.onComplete = options.onComplete || (() => {});
                this.running = false;
                this.cancelled = false;
                this.activeTimeouts = new Set();

                // Simple performance tracking
                this.metrics = {
                    startTime: 0,
                    totalTime: 0,
                    timingLogs: [],
                    actualDelays: []
                };
            }

            // SMOOTH FLOW MODE: Individual element scheduling (No artificial batching)
            async execute() {
                if (this.running || this.cancelled) return;
                this.running = true;
                this.metrics.startTime = performance.now();

                return new Promise((resolve, reject) => {
                    let completedCount = 0;
                    const totalElements = this.elements.length;

                    const checkComplete = () => {
                        completedCount++;
                        this.onProgress(completedCount, totalElements, this.metrics);

                        if (completedCount >= totalElements) {
                            this.running = false;
                            this.metrics.totalTime = performance.now() - this.metrics.startTime;
                            this.onComplete(this.metrics);
                            resolve(this.metrics);
                        }
                    };

                    // GROK'S QUEUE-FRIENDLY SOLUTION: Controlled batch scheduling
                    // Prevent browser queue saturation while maintaining smooth flow
                    const BATCH_SIZE = 50; // Process 50 elements at a time
                    const BATCH_INTERVAL = 10; // 10ms between batches

                    const processBatch = (startIndex) => {
                        if (this.cancelled || this.abortSignal?.aborted) {
                            reject(new Error('Execution cancelled'));
                            return;
                        }

                        const endIndex = Math.min(startIndex + BATCH_SIZE, this.elements.length);

                        // Schedule this batch of elements
                        for (let i = startIndex; i < endIndex; i++) {
                            const element = this.elements[i];

                            // CLEAN TIMING: baseDelay + random jitter (pure timing only)
                            // If baseDelay is 0, run at full speed (no setTimeout)
                            const baseDelay = this.baseDelay + Math.random() * this.maxJitter;
                            const adjustedDelay = this.baseDelay === 0 ? 0 : Math.max(1, baseDelay);

                            const scheduledTime = performance.now();

                            const executeElement = () => {
                                // CRITICAL FIX: Check abort status before executing
                                if (this.cancelled || this.abortSignal?.aborted) {
                                    return; // Skip execution if cancelled
                                }

                                try {
                                    this.onElement(element, i);

                                    // Simple performance tracking
                                    const actualTime = performance.now();
                                    const actualDelay = actualTime - scheduledTime;
                                    this.metrics.actualDelays.push(actualDelay);
                                    this.metrics.timingLogs.push({
                                        index: i,
                                        scheduledDelay: adjustedDelay,
                                        actualDelay: actualDelay
                                    });

                                    checkComplete();
                                } catch (error) {
                                    this.running = false;
                                    reject(error);
                                }
                            };

                            if (adjustedDelay === 0) {
                                // Full speed execution - no setTimeout
                                executeElement();
                            } else {
                                // Timed execution
                                const timeout = setTimeout(() => {
                                    executeElement();
                                    this.activeTimeouts.delete(timeout);
                                }, adjustedDelay);
                                this.activeTimeouts.add(timeout);
                            }
                        }

                        // Schedule next batch if needed
                        if (endIndex < this.elements.length) {
                            setTimeout(() => processBatch(endIndex), BATCH_INTERVAL);
                        }
                    };

                    // Start processing batches
                    processBatch(0);
                });
            }

            cancel() {
                this.cancelled = true;
                this.running = false;
                this.activeTimeouts.forEach(clearTimeout);
                this.activeTimeouts.clear();
            }
        }

        // Enhanced Performance tracking
        const stats = {
            eventCount: 0,
            lastEventTime: 0,
            eventsPerSecond: 0,
            eventTimings: [],
            peakEventsPerSecond: 0,
            testStartTime: 0,
            stressTestStartTime: 0,
            timerInterval: null,

            // Character counting for accurate text event calculation
            actualCharactersTyped: 0,
            textInputCount: 0,

            // Calculate real-time events per second
            updateEventsPerSecond() {
                const now = performance.now();
                this.eventTimings.push(now);

                // Keep only last 10 events for moving average
                if (this.eventTimings.length > 10) {
                    this.eventTimings.shift();
                }

                // Calculate events per second over the last window
                if (this.eventTimings.length >= 2) {
                    const timeWindow = this.eventTimings[this.eventTimings.length - 1] - this.eventTimings[0];
                    this.eventsPerSecond = Math.round((this.eventTimings.length / timeWindow) * 1000);

                    // Track peak performance
                    if (this.eventsPerSecond > this.peakEventsPerSecond) {
                        this.peakEventsPerSecond = this.eventsPerSecond;
                    }

                    // Update UI
                    const epsElement = document.getElementById('eventsPerSecond');
                    const peakElement = document.getElementById('peakEventsPerSecond');
                    if (epsElement) epsElement.textContent = this.eventsPerSecond;
                    if (peakElement) peakElement.textContent = this.peakEventsPerSecond;

                    // Update performance bar (0-1000 events/sec scale)
                    const performanceBar = document.getElementById('performanceBar');
                    const statusElement = document.getElementById('throughputStatus');
                    if (performanceBar) {
                        const percentage = Math.min((this.eventsPerSecond / 1000) * 100, 100);
                        performanceBar.style.width = percentage + '%';

                        // Update status text with benchmark zones
                        if (statusElement) {
                            if (this.eventsPerSecond === 0) {
                                statusElement.textContent = 'Ready';
                                statusElement.style.color = '#666';
                            } else if (this.eventsPerSecond < 100) {
                                statusElement.textContent = 'Light Load';
                                statusElement.style.color = '#28a745';
                            } else if (this.eventsPerSecond < 500) {
                                statusElement.textContent = 'Moderate Load';
                                statusElement.style.color = '#ffc107';
                            } else if (this.eventsPerSecond < 800) {
                                statusElement.textContent = 'Heavy Load';
                                statusElement.style.color = '#dc3545';
                            } else {
                                statusElement.textContent = 'BROWSER LIMIT!';
                                statusElement.style.color = '#8b0000';
                                statusElement.style.fontWeight = 'bold';
                            }

                            // Show approaching benchmark zone
                            if (this.eventCount > 2500) {
                                statusElement.textContent += ' ⚠️ Browser Stress Zone';
                            } else if (this.eventCount > 3000) {
                                statusElement.textContent += ' 🔥 Critical Zone';
                            }
                        }
                    }
                }
            },

            resetMetrics() {
                this.eventCount = 0;
                this.eventsPerSecond = 0;
                this.eventTimings = [];
                this.peakEventsPerSecond = 0;
                this.testStartTime = performance.now();
                this.actualCharactersTyped = 0;
                this.textInputCount = 0;
                this.stopTimer();
            },

            // BEAST MODE TIMER METHODS
            startTimer() {
                this.stressTestStartTime = performance.now();
                this.updateTimerDisplay();

                // Update timer every 100ms for smooth display
                this.timerInterval = setInterval(() => {
                    this.updateTimerDisplay();
                }, 100);
            },

            stopTimer() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                }
            },

            updateTimerDisplay() {
                if (this.stressTestStartTime === 0) return;

                const elapsed = performance.now() - this.stressTestStartTime;
                const totalSeconds = Math.floor(elapsed / 1000);
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                const milliseconds = Math.floor((elapsed % 1000) / 10); // Two digit ms

                const timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${milliseconds.toString().padStart(2, '0')}`;

                const timerElement = document.getElementById('stressTestDuration');
                if (timerElement) {
                    timerElement.textContent = timeString;

                    // Add pulsing effect during intense phases
                    if (this.eventsPerSecond > 5000) {
                        timerElement.style.animation = 'pulse 0.5s 4';
                    } else {
                        timerElement.style.animation = 'none';
                    }
                }
            },

            // ULTIMATE STRESS LOG SYSTEM (localStorage)
            saveStressLog() {
                    // Get current log count or initialize
                    let logCount = parseInt(localStorage.getItem('StressLog_Count') || '0');
                    logCount++;

                    const expected = calculateExpectedTotalEvents();
                    const finalElapsed = this.stressTestStartTime > 0 ?
                        performance.now() - this.stressTestStartTime : 0;

                    const logEntry = {
                        timestamp: new Date().toISOString(),
                        mode: currentMode.toUpperCase(),
                        totalEvents: this.eventCount,
                        eventsPerSecond: this.eventsPerSecond,
                        peakEventsPerSecond: this.peakEventsPerSecond,
                        took: {
                            totalMs: Math.round(finalElapsed),
                            formatted: this.formatDuration(finalElapsed)
                        },
                        elements: {
                            totalElements: expected.totalElements,
                            totalButton: parseInt(benchmarkConfig.test.createTotalButton),
                            totalText: parseInt(benchmarkConfig.test.createTotalText),
                            totalCheckbox: parseInt(benchmarkConfig.test.createTotalCheckbox),
                            totalRadiobox: parseInt(benchmarkConfig.test.createTotalRadiobox),
                            totalSelect: parseInt(benchmarkConfig.test.createTotalSelect),
                            expectedEvents: expected.expectedEvents,
                            firedEvents: this.eventCount,
                            actualVsExpected: `${this.eventCount}/${expected.expectedEvents}`
                        },
                        config: {
                            logLevel: getLogLevel(),
                            // timeout: {
                            //     min: parseInt(benchmarkConfig.simulateUsage.timeout.min),
                            //     max: parseInt(benchmarkConfig.simulateUsage.timeout.max)
                            // },
                            formElFocus: benchmarkConfig.test.formElFocus,
                            eventTypes: benchmarkConfig.test.eventTypes
                        },
                        performance: {
                            breakdown: expected.breakdown,
                            averageEventTime: finalElapsed / this.eventCount,
                            systemLoad: this.eventsPerSecond > 10000 ? 'BROWSER_LIMIT' :
                                       this.eventsPerSecond > 5000 ? 'HEAVY' :
                                       this.eventsPerSecond > 1000 ? 'MODERATE' : 'LIGHT'
                        }
                    };

                    // Save log entry (compact one-liner for storage efficiency)
                    localStorage.setItem(`StressLog_${logCount}`, JSON.stringify(logEntry));
                    localStorage.setItem('StressLog_Count', logCount.toString());

                    // Save latest for easy access (formatted for console viewing)
                    localStorage.setItem('StressLog_Latest', JSON.stringify(logEntry, null, 2));
                    logMessage(`📊 Stress log saved as StressLog_${logCount}`, '#4caf50');
                    console.log('📊 ULTIMATE STRESS LOG SAVED:', logEntry);

                    return logEntry;

                try {

                } catch (error) {
                    console.error('Failed to save stress log:', error);
                    logMessage('❌ Failed to save stress log: ' + error.message, '#f44336');
                }
            },

            formatDuration(ms) {
                const totalSeconds = Math.floor(ms / 1000);
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                const milliseconds = Math.floor(ms % 1000);
                return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${milliseconds.toString().padStart(3, '0')}`;
            }
        };

        const ypsilonHandler = {
            instance: null
        };

        const states = {
            elementsCreated: null
        };

        // Manual event listener management
        const manualListeners = new Map();
        const eventLog = document.getElementById('eventLog');

        // Controller element getters & helpers

        // Basic textContent to data-attribute flip
        // <button data-action="stressTest" data-text="STRESSING">STRESSTEST</button>
        function flipDataText(target) {
            const textContent = target.dataset.text;
            target.dataset.text = target.textContent;
            target.textContent = textContent;
        }

        // Timeout range elements
        function getTimeoutRange() {
            return {
                min: document.getElementById('actionTimeRangeMin') || null,
                max: document.getElementById('actionTimeRangeMax') || null,
            }
        }

        // Get mode switch elements
        function getSetModeSwitch() {
            const getSwitch = document.querySelectorAll('[data-action="setMode"][data-mode]');
            let switchBtn = { active: null };
            if (getSwitch.length) {
                getSwitch.forEach((element) => {
                    switchBtn[element.dataset.mode] = element;

                    if (element.classList.contains('active')) {
                        switchBtn['active'] = element.dataset.mode;
                    }
                });
            }
            return switchBtn; // { currentMode: manual|ypsilon }
        }

        // Restore from localStorage helper
        function restoreConfigFromStorage()  {
            let getConfigFromStorage = localStorage.getItem('StressLog_Config');
            if (getConfigFromStorage) {
                getConfigFromStorage = JSON.parse(getConfigFromStorage);
                // Elements used for reactive configuration.
                if (getConfigFromStorage.test) {
                    const testConfig = getConfigFromStorage.test;
                    for (const [key, value] of Object.entries(testConfig)) {
                        const element = document.querySelector(`[data-action][data-key="${key}"]`);
                        if (element && typeof value !== 'undefined') {
                            if (['formElFocus', 'onceOnly'].includes(key)) {
                                element.checked = !!value; // restore checkboxes
                            } else {
                                element.value = value; // restore input["number"]
                            }
                        }
                    }
                }
                // // Restore Timeout range
                // const timeoutConfig = getConfigFromStorage.simulateUsage?.timeout;
                // if (timeoutConfig && (timeoutConfig?.min && timeoutConfig?.max)) {
                //     const timeRanger = getTimeoutRange();
                //     timeRanger.min.value = timeoutConfig.min;
                //     timeRanger.max.value = timeoutConfig.max;
                // }
                // restoreModeFromStorage();
                if (getConfigFromStorage.currentMode) {
                    // Get switch buttons
                    const getModes = getSetModeSwitch();
                    // Mode stored in storage
                    const mode = getConfigFromStorage.currentMode;
                    // ignore if same
                    if (mode !== getModes.active) {
                        getModes[mode].classList.add('active');
                        getModes[getModes.active].classList.remove('active');
                    }
                }
            }
        }

        /**
         * Overwrite config input values with localStorage
         */
        restoreConfigFromStorage();

        /**
         * BenchMarkHandler setup, UI interaction handler
         */
        class BenchMarkHandler extends YpsilonEventHandler {
            constructor(eventMapping, aliases, config) {
                super(eventMapping, aliases, config);

                this.cache = new Map();
                this.activeModeEl = null; // active manual/ypsilon mode switch el
                this.timerConfigTimeout = null; // debounce timeout for timer config
            }

            // super handler
            handleClick(e, t)  { this.proxyHandle(e, t) }
            handleInput(e, t)  { this.proxyHandle(e, t) }
            handleChange(e, t) { this.proxyHandle(e, t) }

            // DRY Proxy for Super handler
            proxyHandle(event, target) {
                const action = target.dataset.action;
                if (!action) return;

                if (typeof this[action] === 'function') {
                    return this[action](target, event);
                } else {
                    // Searches in config.methods for handler
                    const resolvedHandler = this.resolveHandler(action, 'click');

                    if (typeof resolvedHandler === 'function') {
                        resolvedHandler.call(this, target, event)
                    }
                }
            }

            // Cache helper
            setCache(cacheKey, cacheVal) { this.cache.set(cacheKey, cacheVal) }
            deleteCache(cacheKey)        { this.cache.remove(cacheKey) }
            getCache(cacheKey)           { return this.cache.get(cacheKey) }

            // Reactive config, use data-key for the resolver and set up the resolver in `getSetTestValue`
            setTestConfig(target, event) {
                if (event.type !== 'change') return;

                const key = target.dataset.key;

                if (key) {
                    benchmarkConfig.test[key] = this.getSetTestValue(key, target);

                    // Update dynamic target info when element counts change
                    if (key.startsWith('createTotal')) {
                        updateDynamicTargetInfo();
                    }

                    // Special handling for eventTypes - recreate YpsilonHandler
                    if (key === 'eventTypes' && currentMode === 'ypsilon' && ypsilonHandler.instance) {
                        logMessage('🔄 Event types changed - recreating YpsilonEventHandler...', '#00aa88');
                        ypsilonHandler.instance.destroy();
                        ypsilonHandler.instance = new YpsilonHandler();
                    }
                }

                this.updateUiConfig();
            }

            // Used to resolve config values, if data-action="setTestConfig" used. Set the value to return for each key.
            getSetTestValue(key, target) {
                if (key === 'syncAllElements') {
                    if (target.value) {
                        const getElementCounter = document.querySelectorAll('[data-action="setTestConfig"][data-group]');
                        getElementCounter.forEach((element, index) => {
                            element.value = target.value;
                            element.dispatchEvent(new Event('change', {
                                bubbles: true
                            }));
                        });
                    }
                }
                else {
                    switch(key) {
                        // Input values
                        case 'nestingDepth':
                        case 'createTotalButton':
                        case 'createTotalText':
                        case 'createTotalCheckbox':
                        case 'createTotalRadiobox':
                        case 'createTotalSelect':
                        case 'createTotalDiv':      return target.value;
                        // Checkboxes
                        case 'formElFocus':
                        case 'onceOnly':            return target.checked;
                        // Complex data
                        case 'eventTypes':          return Array.from(target.selectedOptions).map(option => option.value);
                    }
                }
                return null;
            }

            // DEBOUNCED TIMER CONFIG - Let users type without interference
            updateTimerConfig(target, event) {
                // Clear any existing timeout
                if (this.timerConfigTimeout) {
                    clearTimeout(this.timerConfigTimeout);
                }

                // Determine if we should debounce based on event type
                const shouldDebounce = event && (event.type === 'input' || event.type === 'keyup');

                // If it's a change/blur event, update immediately
                if (!shouldDebounce || event?.type === 'change' || event?.type === 'blur') {
                    this._performTimerConfigUpdate(target);
                    return;
                }

                // // Otherwise debounce for 800ms to let user finish typing
                // this.timerConfigTimeout = setTimeout(() => {
                //     this._performTimerConfigUpdate(target);
                // }, 800);

                // this.updateUiConfig();
            }

            // _performTimerConfigUpdate(activeTarget = null) {
            //     let actionTimeRangeMin = this.getCache('actionTimeRangeMin');
            //     let actionTimeRangeMax = this.getCache('actionTimeRangeMax');
            //     let getRangeElements;

            //     if (!actionTimeRangeMin) {
            //         getRangeElements = getTimeoutRange();
            //         actionTimeRangeMin = getRangeElements.min;
            //         this.setCache('actionTimeRangeMin', actionTimeRangeMin);
            //     }
            //     if (!actionTimeRangeMax) {
            //         if (!getRangeElements) {
            //             getRangeElements = getTimeoutRange();
            //         }
            //         actionTimeRangeMax = getRangeElements.max;
            //         this.setCache('actionTimeRangeMax', actionTimeRangeMax);
            //     }

            //     if (actionTimeRangeMin?.value && actionTimeRangeMax?.value) {
            //         // min.value can not be bigger or equal to max.value
            //         // refresh attributes, ensure: { min: 0+, max: 1+ }
            //         const minVal = parseInt(actionTimeRangeMin.value, 10);
            //         const maxVal = parseInt(actionTimeRangeMax.value, 10);

            //         // SMART VALIDATION: Only adjust the field user is NOT currently editing
            //         const isEditingMin = activeTarget === actionTimeRangeMin;
            //         const isEditingMax = activeTarget === actionTimeRangeMax;

            //         // max.min can not be smaller than [min.value || 1]
            //         actionTimeRangeMax.min = minVal + 1 > 0 ? minVal + 1 : 1;

            //         // Ensure valid min, max & value attributes
            //         if (minVal >= 0 && maxVal > 0 && minVal <= maxVal) {
            //             actionTimeRangeMin.max = maxVal - 1;
            //         }

            //         // Only adjust other field, never the one being edited
            //         if (minVal >= maxVal) {
            //             if (!isEditingMax) {
            //                 actionTimeRangeMax.value = minVal + 1;
            //             } else if (!isEditingMin) {
            //                 actionTimeRangeMin.value = maxVal - 1;
            //             }
            //         }
            //         if (maxVal < minVal) {
            //             if (!isEditingMax) {
            //                 actionTimeRangeMax.value = minVal + 1;
            //             } else if (!isEditingMin) {
            //                 actionTimeRangeMin.value = maxVal - 1;
            //             }
            //         }
            //         if (minVal <= 0) { // negative prevention
            //             actionTimeRangeMin.value = 0;
            //         }
            //         if (maxVal <= 0) { // negative prevention
            //             actionTimeRangeMin.min = 0;
            //             actionTimeRangeMin.value = 0;
            //             actionTimeRangeMax.min = 0;
            //             actionTimeRangeMax.value = 0;
            //         }
            //         // Set timeout range
            //         benchmarkConfig.simulateUsage.timeout = {
            //             min: actionTimeRangeMin.value || 25,
            //             max: actionTimeRangeMax.value || 26
            //         }
            //     }

            //     this.updateUiConfig();
            // }

            // Config has changed

            updateUiConfig() {
                let currentConfiguration = this.getCache('currentConfiguration');

                if (!currentConfiguration) {
                    currentConfiguration = document.getElementById('currentConfiguration');
                    this.setCache('currentConfiguration', currentConfiguration);
                }

                currentConfiguration.textContent = JSON.stringify({ currentMode, benchmarkConfig, stats }, null, 1);

                // Store current config in localStorage to restore
                localStorage.setItem('StressLog_Config', JSON.stringify({ currentMode, ...benchmarkConfig }, null, 0));
            }

            /**
             * Action handler
             */

            async setMode(target) {
                if (this.activeModeEl === target) return;

                currentMode = target.dataset.mode || currentMode;
                let modeCache = this.getCache('modeSwitch');

                if (this.activeModeEl) {
                    this.activeModeEl.classList.remove('active');
                } else {
                    document.querySelector('.active[data-action="setMode"]').classList.remove('active');
                }

                this.activeModeEl = target;
                target.classList.add('active');

                if (!modeCache) {
                    this.setCache('modeSwitch', modeCache = {
                        manualTest: document.getElementById('manualTest'),
                        ypsilonTest: document.getElementById('ypsilonTest'),
                    });
                }

                modeCache.manualTest.classList.toggle('hidden', currentMode !== 'manual');
                modeCache.ypsilonTest.classList.toggle('hidden', currentMode !== 'ypsilon');

                this.clearConflictingElements(); // removes conflicting elements, switches auto between [manualTest|ypsilon]
                this.disableStressTestButtons(); // Disable stress tests when switching modes

                this._toggleYpsilonHandler();

                // Update element counter after mode switch
                this.updateElementCount();

                this.updateUiConfig();
            }

            // Removes conflicting elements on setMode
            clearConflictingElements() {
                const clearId = currentMode === 'manual' ? 'ypsilonElements' : 'manualElements';
                const cacheKey = `testContainer.${clearId}`;
                let testContainer = this.getCache(cacheKey);

                if (!testContainer) {
                    this.setCache(cacheKey, testContainer = document.getElementById(clearId));
                }

                testContainer.innerHTML = '';
            }

            // Removes all elements, complete clear
            clearElements(target) {
                let manualElements = this.getCache('manualElements');
                let ypsilonElements = this.getCache('ypsilonElements');

                this.disableStressTestButtons();

                if (!manualElements) {
                    manualElements = document.getElementById('manualElements');
                    this.setCache('manualElements', manualElements);
                }
                if (!ypsilonElements) {
                    ypsilonElements = document.getElementById('ypsilonElements');
                    this.setCache('ypsilonElements', ypsilonElements);
                }

                // Traditional manual cleanup nightmare - must removeEventListener for each bound function
                manualListeners.forEach((listenerData, element) => {
                    try {
                        // Must use the exact same bound function reference for removal
                        element.removeEventListener(listenerData.type, listenerData.handler);
                    } catch (e) {
                        // Cleanup can fail if element already removed or bound function lost
                        console.warn('Manual listener cleanup failed:', e);
                    }
                });

                manualElements.innerHTML = '';
                ypsilonElements.innerHTML = '';
                manualListeners.clear();
                states.elementsCreated = null;
                // Update element counter after clearing
                this.updateElementCount();
            }

            _toggleYpsilonHandler() {
                if (currentMode === 'manual' && ypsilonHandler.instance !== null) {
                    ypsilonHandler.instance.destroy();
                    ypsilonHandler.instance = null;
                } else if (currentMode === 'ypsilon' && !ypsilonHandler.instance) {
                    ypsilonHandler.instance = new YpsilonHandler();
                }
            }

            generateElements(target) {
                const count = benchmarkConfig.test.createTotalButton;
                states.elementsCreated = currentMode;
                document.body.classList.add('elements-generated');

                // Generate all element types in both containers
                if (currentMode === 'manual') {
                    generateAllElements('manualElements', true);
                } else {
                    generateAllElements('ypsilonElements', false);
                }

                // Update element counter after generation
                this.updateElementCount();

                // Enable stress test buttons after elements are created
                this.enableStressTestButtons();
            }

            enableStressTestButtons() {
                const stressTestButtons = document.querySelectorAll('.stress-test-btn');
                stressTestButtons.forEach(button => {
                    button.disabled = false;
                    // Re-enable animation for Infinity Test button
                    if (button.dataset.action === 'infinityTest') {
                        button.style.animation = 'glow 2s infinite';
                    }
                });
            }

            disableStressTestButtons() {
                const stressTestButtons = document.querySelectorAll('.stress-test-btn');
                stressTestButtons.forEach(button => {
                    // Don't disable the "Create elements" button unless a test is actually running
                    if (button.dataset.action === 'generateElements' && !testState.isRunning) {
                        return;
                    }
                    button.disabled = true;
                });
            }

            updateElementCount() {
                let elementCountEl = this.getCache('elementCount');
                if (!elementCountEl) {
                    elementCountEl = document.getElementById('elementCount');
                    this.setCache('elementCount', elementCountEl);
                }

                if (!elementCountEl) return;

                // Count elements in the currently active container
                const activeContainer = currentMode === 'manual'
                    ? document.getElementById('manualElements')
                    : document.getElementById('ypsilonElements');

                if (activeContainer) {
                    const count = activeContainer.querySelectorAll('button, input, select, div[data-action]').length;
                    elementCountEl.textContent = count.toLocaleString();
                } else {
                    elementCountEl.textContent = '0';
                }
            }

            startTest(testName, abortController = null) {
                testState.isRunning = true;
                testState.currentTest = testName;
                testState.abortController = abortController;

                // Reset performance metrics for clean test
                stats.resetMetrics();

                // Show abort button
                const abortButton = document.getElementById('abortTestButton');
                if (abortButton) {
                    abortButton.style.display = 'inline-block';
                }

                // Disable all stress test buttons
                this.disableStressTestButtons();
            }

            endTest() {
                testState.isRunning = false;
                testState.currentTest = null;
                testState.abortController = null;

                // Flush any remaining logs when test ends
                if (loggingSystem.batchTimeout) {
                    clearTimeout(loggingSystem.batchTimeout);
                    loggingSystem.flushBuffer();
                }

                // Hide abort button
                const abortButton = document.getElementById('abortTestButton');
                if (abortButton) {
                    abortButton.style.display = 'none';
                }

                // Re-enable stress test buttons if elements exist
                if (states.elementsCreated) {
                    this.enableStressTestButtons();
                }
            }

            abortTest() {
                if (!testState.isRunning) return;

                logMessage(`⛔ Aborting test: ${testState.currentTest}`, '#f44336');

                // Signal abort if controller exists
                if (testState.abortController) {
                    testState.abortController.abort();
                }

                this.endTest();
            }

            resetStats(target) {
                stats.resetMetrics();
                document.getElementById('eventCount').textContent = '0';
                document.getElementById('eventsPerSecond').textContent = '0';
                document.getElementById('peakEventsPerSecond').textContent = '0';

                // Reset performance bar
                const performanceBar = document.getElementById('performanceBar');
                const statusElement = document.getElementById('throughputStatus');
                if (performanceBar) performanceBar.style.width = '0%';
                if (statusElement) {
                    statusElement.textContent = 'Ready';
                    statusElement.style.color = '#666';
                    statusElement.style.fontWeight = 'normal';
                }

                // Reset benchmark progress
                const benchmarkProgress = document.getElementById('benchmarkProgress');
                const benchmarkBar = document.getElementById('benchmarkBar');
                if (benchmarkProgress) {
                    const expected = calculateExpectedTotalEvents();
                    benchmarkProgress.textContent = `0 / ${expected.expectedEvents}`;
                }
                if (benchmarkBar) {
                    benchmarkBar.style.width = '0%';
                    benchmarkBar.style.background = 'linear-gradient(90deg, #28a745, #17a2b8)';
                }

                // Reset Beast Mode Timer
                const beastTimer = document.getElementById('stressTestDuration');
                if (beastTimer) {
                    beastTimer.textContent = '00:00';
                    beastTimer.style.color = '';
                    beastTimer.style.fontWeight = '';
                    beastTimer.style.animation = '';
                }

                logMessage('📊 Performance metrics reset', '#28a745');
            }

            // ULTIMATE STRESS LOGS VIEWER
            viewStressLogs(target) {
                // Use the new modal instead of alert/console
                this.showStressLogs();
            }

            clearLog(target) {
                let eventLog = this.getCache('eventLog');
                if (!eventLog) {
                    eventLog = document.getElementById('eventLog');
                    this.setCache('eventLog', eventLog);
                }
                eventLog.innerHTML = '';
            }

            stressTest(target) {
                stressTest(target);
            }

            // Infinity test - exponential DOM scaling to test O(1) vs O(n)
            infinityTest(target) {
                infinityTest(target);
            }

            /**
             * Init reactivity, initial values in input elements are used as defaults
             */
            initBenchTool() {
                const getConfigs = document.querySelectorAll('[data-action="setTestConfig"]');

                if (getConfigs.length) {
                    getConfigs.forEach((element, index) => {
                        const key = element.dataset.key;

                        if (key) {
                            benchmarkConfig.test[key] = this.getSetTestValue(key, element);
                            this.setCache(key, element);
                        }
                    });
                }

                // this.updateTimerConfig()
            }

            showStressLogs() {
                const modal = document.getElementById('stressLogsModal');
                const content = document.getElementById('stressLogsContent');

                try {
                    const logCount = parseInt(localStorage.getItem('StressLog_Count') || '0');

                    if (logCount === 0) {
                        content.innerHTML = '<p style="padding: 0 30px 30px;">No stress logs found. Run a stress test to generate logs.</p>';
                        modal.style.display = 'block';
                        return;
                    }

                    // Build table HTML
                    let html = `
                        <table style="width: 98%; border-collapse: collapse; margin: 0 auto 20px;">
                            <thead style="position: sticky; top: 0;">
                                <tr style="background: #f8f9fa;">
                                    <th style="border: 1px solid #ddd; padding: 8px; text-align: left;">Index</th>
                                    <th style="border: 1px solid #ddd; padding: 8px; text-align: left;">Mode</th>
                                    <th style="border: 1px solid #ddd; padding: 8px; text-align: right;">Events</th>
                                    <th style="border: 1px solid #ddd; padding: 8px; text-align: left;">Took</th>
                                    <th style="border: 1px solid #ddd; padding: 8px; text-align: left;">Elements</th>
                                    <th style="border: 1px solid #ddd; padding: 8px; text-align: center;">Depth</th>
                                </tr>
                            </thead>
                            <tbody>
                    `;

                    // Load and display logs (oldest first)
                    for (let i = 1; i <= logCount; i++) {
                        const logData = localStorage.getItem(`StressLog_${i}`);
                        if (logData) {
                            const log = JSON.parse(logData);
                            const elements = log.elements || {};
                            const elementsText = `${elements.totalElements || 0} [B:${elements.totalButton || 0}, T:${elements.totalText || 0}, C:${elements.totalCheckbox || 0}, R:${elements.totalRadiobox || 0}, S:${elements.totalSelect || 0}]`;

                            html += `
                                <tr>
                                    <td style="border: 1px solid #ddd; padding: 8px;">${i}</td>
                                    <td style="border: 1px solid #ddd; padding: 8px;">${log.mode || 'Unknown'}</td>
                                    <td style="border: 1px solid #ddd; padding: 8px; text-align: right;">${log.totalEvents || 0}</td>
                                    <td style="border: 1px solid #ddd; padding: 8px;">${log.took?.formatted || 'N/A'}</td>
                                    <td style="border: 1px solid #ddd; padding: 8px; font-size: 0.9em;">${elementsText}</td>
                                    <td style="border: 1px solid #ddd; padding: 8px; text-align: center;">0</td>
                                </tr>
                            `;
                        }
                    }

                    html += '</tbody></table>';

                    // Add config section
                    let latestConfig = localStorage.getItem('StressLog_Config');
                    if (latestConfig) {
                        latestConfig = JSON.stringify(JSON.parse(latestConfig), null, 2);
                        html += `
                            <div style="padding: 20px;">
                                <h4>StressMacher_Config</h4>
                                <pre class="auto-height" style="background: #f8f9fa; padding: 15px; border-radius: 4px; overflow: auto; font-size: 0.85em;">${latestConfig}</pre>
                            </div>
                        `;
                    }

                    content.innerHTML = html;
                    modal.style.display = 'block';

                } catch (error) {
                    console.error('Error loading stress logs:', error);
                    content.innerHTML = '<p>Error loading stress logs: ' + error.message + '</p>';
                    modal.style.display = 'block';
                }
            }

            closeStressLogs() {
                document.getElementById('stressLogsModal').style.display = 'none';
            }

            stressLogToConsole() {
                // List all stress logs in console with formatted JSON
                const logCount = parseInt(localStorage.getItem('StressLog_Count') || '0');

                if (logCount === 0) {
                    console.log('📊 No stress logs found in localStorage');
                    return;
                }

                console.log(`📊 STRESS LOGS DUMP (${logCount} entries):`);
                console.log('='.repeat(50));

                for (let i = 1; i <= logCount; i++) {
                    const logData = localStorage.getItem(`StressLog_${i}`);
                    if (logData) {
                        console.log(`\n🔥 StressLog_${i}:`);
                        console.log(JSON.stringify(JSON.parse(logData), null, 2));
                    }
                }

                // Also log config and latest
                const config = localStorage.getItem('StressLog_Config');
                const latest = localStorage.getItem('StressLog_Latest');

                if (config) {
                    console.log('\n⚙️ StressLog_Config:');
                    console.log(JSON.stringify(JSON.parse(config), null, 2));
                }

                if (latest) {
                    console.log('\n🔥 StressLog_Latest:');
                    console.log(JSON.stringify(JSON.parse(latest), null, 2));
                }

                console.log('\n📊 All stress logs dumped to console!');
            }

            clearLocalStorage() {
                // Delete all stress log entries
                const logCount = parseInt(localStorage.getItem('StressLog_Count') || '0');

                if (logCount === 0) {
                    alert('No stress logs to clear.');
                    return;
                }

                if (confirm(`Are you sure you want to delete all ${logCount} stress logs from localStorage? This cannot be undone.`)) {
                    // Delete numbered log entries
                    for (let i = 1; i <= logCount; i++) {
                        localStorage.removeItem(`StressLog_${i}`);
                    }

                    // Delete metadata entries
                    localStorage.removeItem('StressLog_Count');
                    localStorage.removeItem('StressLog_Latest');
                    localStorage.removeItem('StressLog_Config');

                    console.log(`🗑️ Deleted ${logCount} stress logs from localStorage`);
                    alert(`Successfully deleted ${logCount} stress logs from localStorage.`);

                    logMessage(`🗑️ Cleared ${logCount} stress logs from localStorage`, '#dc3545');
                } else {
                    console.log('❌ Clear localStorage cancelled by user');
                }
            }

            static getRandomArbitrary(min, max) {
                return parseInt(Math.random() * (max - min) + min, 10);
            }

            static getTimestamp() {
                return new Date().toLocaleTimeString('es-ES', {
                    hour24: false, hour: '2-digit', minute: '2-digit', second: '2-digit'
                });;
            }

            static shuffleArray(array) {
                const shuffled = [...array];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                return shuffled;
            }
        }

        /**
         * To handle page interactions
         *
         */
        const benchTool = new BenchMarkHandler(
            benchmarkSetup.eventMapping,
            benchmarkSetup.aliases,
            benchmarkSetup.config
        );

        benchTool.initBenchTool()

        // Update dynamic target info on page load
        updateDynamicTargetInfo();

        function shuffleArray(array) { return BenchMarkHandler.shuffleArray(array) }
        function getRandomArbitrary() { return BenchMarkHandler.getRandomArbitrary }

        // Batch processing to reduce reflow violations
        async function processInBatches(elements, batchSize, processFn) {
            for (let i = 0; i < elements.length; i += batchSize) {
                const batch = elements.slice(i, i + batchSize);
                await new Promise(resolve => {
                    requestAnimationFrame(() => {
                        batch.forEach(processFn);
                        resolve();
                    });
                });
                await new Promise(resolve => setTimeout(resolve, 50));
            }
        }

        /**
         * YpsilonEventHandler to test setup
         *
         * Needs to be setup correctly to delegate events
         */
        class YpsilonHandler extends YpsilonEventHandler {
            constructor() {
                // Use configurable event types
                const eventTypes = benchmarkConfig.test.eventTypes || ['click', 'input', 'change'];
                super({
                    '#ypsilonElements': eventTypes
                }, {}, {
                    enableGlobalFallback: true,
                    enableConfigValidation: false,
                });
            }

            // Super Event handlers - use DRY proxyHandle pattern like BenchMarkHandler
            handleClick(event, target)     { this.proxyHandle(event, target) }
            handleInput(event, target)     { this.proxyHandle(event, target) }
            handleChange(event, target)    { this.proxyHandle(event, target) }
            handleFocus(event, target)     { this.proxyHandle(event, target) }
            handleBlur(event, target)      { this.proxyHandle(event, target) }
            handleSubmit(event, target)    { this.proxyHandle(event, target) }
            handleKeydown(event, target)   { this.proxyHandle(event, target) }
            handleKeyup(event, target)     { this.proxyHandle(event, target) }
            handleMouseover(event, target) { this.proxyHandle(event, target) }
            handleMouseout(event, target)  { this.proxyHandle(event, target) }

            // DRY Proxy for event handler routing
            proxyHandle(event, target) {
                const action = target.dataset.action;
                if (action && this[action]) {
                    // Filter events: only handle the PRIMARY event type for each element
                    const elementType = target.type || target.tagName.toLowerCase();
                    const eventType = event.type;

                    // Define primary event types for different elements
                    const shouldHandle = this.shouldHandleEvent(elementType, eventType);

                    if (shouldHandle) {
                        this[action](target, event);

                        // Once Only mode: remove data-action to ensure element is touched only once
                        if (benchmarkConfig.test.onceOnly) {
                            target.removeAttribute('data-action');
                            logMessage(`🎯 Once Only: Removed data-action from ${elementType} element`, '#FFA500');
                        }

                        // Log the YpsilonEventHandler action for counting - use actual value like manual does
                        let logAction = target.value || action;
                        logEvent('Ypsilon', logAction, target);
                    }
                }
            }

            // Determine if this event type should be handled for this element type
            shouldHandleEvent(elementType, eventType) {
                // First check if this event type is configured to be handled at all
                const configuredEvents = benchmarkConfig.test.eventTypes || ['click', 'input', 'change'];
                if (!configuredEvents.includes(eventType)) {
                    return false;
                }

                // Then check element-specific primary event preferences
                switch (elementType) {
                    case 'button':
                        return eventType === 'click' || (eventType === 'keydown' || eventType === 'focus' || eventType === 'blur');
                    case 'text':
                    case 'email':
                    case 'password':
                        return eventType === 'input' || (eventType === 'focus' || eventType === 'blur' || eventType === 'keydown' || eventType === 'keyup');
                    case 'checkbox':
                    case 'radio':
                        return eventType === 'change' || (eventType === 'focus' || eventType === 'blur'); // Only handle change, ignore click/input
                    case 'select-one':
                    case 'select-multiple':
                        return eventType === 'change' || (eventType === 'focus' || eventType === 'blur');
                    default:
                        // For unknown elements, allow any configured event type
                        return true;
                }
            }

            // Realistic button action methods
            saveData(target, event) {}
            deleteItem(target, event) {}
            editRecord(target, event) {}
            submitForm(target, event) {}
            cancelAction(target, event) {}

            // Text input action methods
            updateUsername(target, event) {}
            updateEmail(target, event) {}
            updatePassword(target, event) {}
            searchQuery(target, event) {}

            // Checkbox/Radio action methods
            toggleNotifications(target, event) {}
            selectTheme(target, event) {}
            setPrivacyLevel(target, event) {}
            enableFeature(target, event) {}

            // Select action methods
            changeLanguage(target, event) {}
            selectCountry(target, event) {}
            chooseCategory(target, event) {}
            pickTimezone(target, event) {}
        }

        async function simulateButtonClicks(abortSignal = null) {
            return new Promise((resolve, reject) => {
                const buttons = document.querySelectorAll('#manualElements button, #ypsilonElements button');

                logMessage(`🔥 Simulating ${buttons.length} button clicks in RANDOM order...`);

                if (buttons.length === 0) {
                    logMessage('⚠️ No buttons found, skipping button test');
                    resolve();
                    return;
                }

                // RANDOMIZE: Shuffle buttons for random clicking order
                const timer = benchmarkConfig.simulateUsage.timeout;

                // ULTIMATE CHAIN SCHEDULING - NO MORE QUEUE SATURATION!
                const shuffledButtons = shuffleArray([...buttons]);
                const scheduler = new StressMacherUltimate(shuffledButtons, {
                    baseDelay: timer.min,
                    maxJitter: timer.max - timer.min,
                    abortSignal,
                    onElement: (btn) => {
                        btn.dispatchEvent(new PointerEvent('click', { bubbles: true }));
                        if (benchmarkConfig.test.formElFocus) {
                            btn.focus();
                        }
                    },
                    onProgress: (current, total) => {
                        stats.updateEventsPerSecond();
                    },
                    onComplete: () => {
                        setTimeout(resolve, 100);
                    }
                });

                // CRITICAL FIX: Explicitly cancel scheduler when abort signal fires
                if (abortSignal) {
                    abortSignal.addEventListener('abort', () => {
                        scheduler.cancel();
                        reject(new Error('Button simulation aborted'));
                    });
                }

                scheduler.execute().catch(reject);
            });
        }

        async function simulateInputInteractions(abortSignal = null) {
            return new Promise((resolve, reject) => {
                if (abortSignal?.aborted) {
                    reject(new Error('Input simulation aborted'));
                    return;
                }
                const inputs = document.querySelectorAll('#manualElements input[type="text"], #ypsilonElements input[type="text"]');
                const testTexts = ['Hello', 'World', 'Test', 'Performance', 'Monster', 'YpsilonEventHandler'];

                logMessage(`⌨️ Simulating typing in ${inputs.length} text inputs in RANDOM order...`);

                if (inputs.length === 0) {
                    logMessage('⚠️ No text inputs found, skipping input test');
                    resolve();
                    return;
                }

                // RANDOMIZE: Shuffle inputs and texts for random typing order
                const timer = benchmarkConfig.simulateUsage.timeout;
                const timeouts = [];

                // Add abort support with timeout cleanup
                if (abortSignal) {
                    abortSignal.addEventListener('abort', () => {
                        // Clear all pending timeouts
                        timeouts.forEach(clearTimeout);
                        reject(new Error('Input simulation aborted'));
                    });
                }

                // CHAIN SCHEDULING FOR INPUT SIMULATION
                const shuffledInputs = shuffleArray([...inputs]);
                const scheduler = new StressMacherUltimate(shuffledInputs, {
                    baseDelay: timer.min,
                    maxJitter: timer.max - timer.min,
                    abortSignal,
                    onElement: async (input, index) => {
                        if (benchmarkConfig.test.formElFocus) {
                            input.focus();
                        }

                        const text = testTexts[index % testTexts.length];
                        try {
                            // Track text input count and characters for accurate calculation
                            stats.textInputCount++;
                            stats.actualCharactersTyped += text.length;
                            await simulateTyping(input, text, abortSignal);
                        } catch (typingError) {
                            if (!abortSignal?.aborted) {
                                console.warn('Typing simulation interrupted:', typingError.message);
                            }
                        }

                        if (benchmarkConfig.test.formElFocus) {
                            setTimeout(() => input.blur(), text.length * 50);
                        }
                    },
                    onProgress: (current, total) => {
                        stats.updateEventsPerSecond();
                    },
                    onComplete: () => {
                        setTimeout(resolve, 200);
                    }
                });

                // CRITICAL FIX: Explicitly cancel scheduler when abort signal fires
                if (abortSignal) {
                    abortSignal.addEventListener('abort', () => {
                        scheduler.cancel();
                        reject(new Error('Input simulation aborted'));
                    });
                }

                scheduler.execute().catch(reject);
            });
        }

        async function simulateTyping(input, text, abortSignal = null) {
            return new Promise((resolve, reject) => {
                let currentText = '';

                // CHAIN SCHEDULING FOR TYPING CHARACTERS
                const characters = [...text];
                const scheduler = new StressMacherUltimate(characters, {
                    baseDelay: 25,
                    maxJitter: 60,
                    abortSignal,
                    onElement: (char) => {
                        currentText += char;
                        input.value = currentText;
                        input.dispatchEvent(new InputEvent('input', {
                            bubbles: true,
                            data: char
                        }));
                    },
                    onComplete: () => {
                        setTimeout(resolve, 50);
                    }
                });

                // CRITICAL FIX: Explicitly cancel scheduler when abort signal fires
                if (abortSignal) {
                    abortSignal.addEventListener('abort', () => {
                        scheduler.cancel();
                        resolve(); // Resolve instead of reject to avoid uncaught promise
                    });
                }

                scheduler.execute().catch(() => resolve());
            });
        }

        async function simulateCheckboxRadio(abortSignal = null) {
            if (abortSignal?.aborted) throw new Error('Checkbox/Radio simulation aborted');

            return new Promise((resolve, reject) => {
                const checkboxes = document.querySelectorAll('#manualElements input[type="checkbox"], #ypsilonElements input[type="checkbox"]');
                const radios = document.querySelectorAll('#manualElements input[type="radio"], #ypsilonElements input[type="radio"]');
                const timer = benchmarkConfig.simulateUsage.timeout;

                if (checkboxes.length === 0 && radios.length === 0) {
                    logMessage('⚠️ No checkboxes or radio buttons found, skipping checkbox test');
                    resolve();
                    return;
                }

                logMessage(`☑️ Simulating ${checkboxes.length} checkboxes and ${radios.length} radio buttons in RANDOM order...`);

                const timeouts = [];
                let completedCount = 0;
                const totalElements = checkboxes.length + [...radios].filter(radio => !radio.checked).length;

                // Add abort support
                if (abortSignal) {
                    abortSignal.addEventListener('abort', () => {
                        timeouts.forEach(clearTimeout);
                        reject(new Error('Checkbox/Radio simulation aborted'));
                    });
                }

                // CHAIN SCHEDULING FOR CHECKBOXES AND RADIOS
                const shuffledCheckboxes = shuffleArray([...checkboxes]);
                const uncheckedRadios = shuffleArray([...radios]).filter(radio => !radio.checked);
                const allElements = [...shuffledCheckboxes, ...uncheckedRadios];

                if (allElements.length === 0) {
                    resolve();
                    return;
                }

                const scheduler = new StressMacherUltimate(allElements, {
                    baseDelay: timer.min,
                    maxJitter: timer.max - timer.min,
                    abortSignal,
                    onElement: (element) => {
                        if (benchmarkConfig.test.formElFocus) {
                            element.focus();
                        }

                        if (element.type === 'checkbox') {
                            element.checked = !element.checked;
                        } else if (element.type === 'radio') {
                            element.checked = true;
                        }

                        element.dispatchEvent(new Event('change', { bubbles: true }));
                    },
                    onProgress: (current, total) => {
                        stats.updateEventsPerSecond();
                    },
                    onComplete: () => {
                        setTimeout(resolve, 100);
                    }
                });

                // CRITICAL FIX: Explicitly cancel scheduler when abort signal fires
                if (abortSignal) {
                    abortSignal.addEventListener('abort', () => {
                        scheduler.cancel();
                        reject(new Error('Checkbox/Radio simulation aborted'));
                    });
                }

                scheduler.execute().catch(reject);

                // If no elements to process, resolve immediately
                if (totalElements === 0) {
                    resolve();
                }
            });
        }

        async function simulateFormInteractions(abortSignal = null) {
            if (abortSignal?.aborted) throw new Error('Form simulation aborted');
            return new Promise((resolve) => {
                const selects = document.querySelectorAll('#manualElements select, #ypsilonElements select');
                const timer = benchmarkConfig.simulateUsage.timeout;

                logMessage(`📋 Simulating ${selects.length} form interactions...`);

                if (selects.length === 0) {
                    logMessage('⚠️ No select elements found, skipping form test');
                    resolve();
                    return;
                }

                // CHAIN SCHEDULING FOR SELECT ELEMENTS
                const shuffledSelects = shuffleArray([...selects]);
                const scheduler = new StressMacherUltimate(shuffledSelects, {
                    baseDelay: timer.min,
                    maxJitter: timer.max - timer.min,
                    abortSignal,
                    onElement: (select) => {
                        if (select.options.length > 1) {
                            if (benchmarkConfig.test.formElFocus) {
                                select.focus();
                            }

                            const randomIndex = Math.floor(Math.random() * select.options.length);
                            select.selectedIndex = randomIndex;
                            select.dispatchEvent(new Event('change', { bubbles: true }));
                        }
                    },
                    onProgress: (current, total) => {
                        stats.updateEventsPerSecond();
                    },
                    onComplete: () => {
                        setTimeout(resolve, 200);
                    }
                });

                // CRITICAL FIX: Explicitly cancel scheduler when abort signal fires
                if (abortSignal) {
                    abortSignal.addEventListener('abort', () => {
                        scheduler.cancel();
                        resolve(); // Resolve instead of reject to avoid uncaught promise
                    });
                }

                scheduler.execute().catch(() => resolve());
            });
        }

        async function simulateMouseBehaviors(abortSignal = null) {
            if (abortSignal?.aborted) throw new Error('Mouse simulation aborted');
            return new Promise((resolve) => {
                const allElements = document.querySelectorAll('#manualElements *, #ypsilonElements *');
                const sampleElements = [...allElements].slice(0, Math.min(10, allElements.length));

                logMessage(`🖱️ Simulating mouse behaviors on ${sampleElements.length} elements...`);

                // CHAIN SCHEDULING FOR MOUSE BEHAVIORS
                const scheduler = new StressMacherUltimate(sampleElements, {
                    baseDelay: 50,
                    maxJitter: 150,
                    abortSignal,
                    onElement: (element) => {
                        element.dispatchEvent(new MouseEvent('mouseenter', { bubbles: true }));
                        setTimeout(() => {
                            element.dispatchEvent(new MouseEvent('mouseleave', { bubbles: true }));
                        }, 100);
                    },
                    onProgress: (current, total) => {
                        stats.updateEventsPerSecond();
                    },
                    onComplete: () => {
                        setTimeout(resolve, 300);
                    }
                });

                // CRITICAL FIX: Explicitly cancel scheduler when abort signal fires
                if (abortSignal) {
                    abortSignal.addEventListener('abort', () => {
                        scheduler.cancel();
                        resolve(); // Resolve instead of reject to avoid uncaught promise
                    });
                }

                scheduler.execute().catch(() => resolve());
            });
        }

        async function stressTest(target) {
            const abortController = new AbortController();

            try {
                this.flipDataText(target);
                target.disabled = true;

                // Start test state management
                benchTool.startTest('STRESSTEST', abortController);

                // START BEAST MODE TIMER
                stats.startTimer();

                logMessage('🔥 STRESSTEST: Generating ALL element types simultaneously!');
                markTestArea('running', 'add');

                if (states.elementsCreated !== currentMode) {
                    generateAllElementsOnly();
                }

                // Check for abort
                if (abortController.signal.aborted) throw new Error('Test aborted');

                await new Promise((resolve, reject) => {
                    const timeout = setTimeout(resolve, 1000);
                    abortController.signal.addEventListener('abort', () => {
                        clearTimeout(timeout);
                        reject(new Error('Test aborted'));
                    });
                });

                // Start comprehensive stress testing
                logMessage('🚀 UFF TEST: Starting comprehensive stress test...');

                // Check for abort before running stress tests
                if (abortController.signal.aborted) throw new Error('Test aborted');

                // Run all stress tests simultaneously with abort support
                await Promise.allSettled([
                    simulateButtonClicks(abortController.signal),
                    simulateInputInteractions(abortController.signal),
                    simulateCheckboxRadio(abortController.signal),
                    simulateFormInteractions(abortController.signal),
                    simulateMouseBehaviors(abortController.signal)
                ]).then(results => {
                    // Check if any simulation was actually aborted
                    const abortedResults = results.filter(r =>
                        r.status === 'rejected' && r.reason?.message?.includes('aborted')
                    );

                    if (abortedResults.length > 0 && !abortController.signal.aborted) {
                        // Simulations were aborted but controller wasn't - this is unexpected
                        throw new Error('Simulations aborted unexpectedly');
                    } else if (abortController.signal.aborted) {
                        // This is expected abort - throw to exit gracefully
                        throw new Error('Test aborted');
                    }

                    // Log any other failures
                    results.forEach((result, index) => {
                        if (result.status === 'rejected' && !result.reason?.message?.includes('aborted')) {
                            const simNames = ['Button', 'Input', 'Checkbox/Radio', 'Form', 'Mouse'];
                            console.warn(`${simNames[index]} simulation failed:`, result.reason);
                        }
                    });
                });

                // Mark test as finished
                markTestArea('running', 'remove');
                markTestArea('finished', 'add');

                // Wait for final memory cleanup and measurement
                await new Promise(resolve => setTimeout(resolve, 500));

                // Cleanup UI
                setTimeout(() => {
                    this.flipDataText(target);
                    target.disabled = false;
                                        markTestArea('finished', 'remove');
                    benchTool.endTest(); // End test state management

                    // STOP BEAST MODE TIMER
                    stats.stopTimer();

                    // UPDATE FINAL ACCURATE CALCULATION
                    const actualExpected = calculateActualExpectedEvents();
                    const benchmarkProgress = document.getElementById('benchmarkProgress');
                    if (benchmarkProgress) {
                        benchmarkProgress.textContent = `${stats.eventCount} / ${actualExpected.expectedEvents} (${stats.actualCharactersTyped} chars typed)`;
                        // Make text green if events match exactly
                        if (stats.eventCount === actualExpected.expectedEvents) {
                            benchmarkProgress.style.color = '#4caf50';
                            benchmarkProgress.style.fontWeight = 'bold';
                        } else {
                            benchmarkProgress.style.color = '#f44336'; // Red if mismatch
                            benchmarkProgress.style.fontWeight = 'bold';
                        }
                    }

                    logMessage(`🎯 Final accurate count: ${stats.eventCount} events (${actualExpected.actualCharacters} characters in ${actualExpected.textInputs} text inputs)`, '#17a2b8');

                    // SAVE ULTIMATE STRESS LOG
                    stats.saveStressLog();

                    logMessage('🎖️ Ultimate Fury Fire Test COMPLETED successfully!', '#4caf50');
                }, 2000);

            } catch (error) {
                console.error('STRESSTEST failed:', error);

                const isAborted = error.message === 'Test aborted';
                if (!isAborted) {
                    logMessage('❌ STRESSTEST failed: ' + error.message, '#ff5722');
                }

                // Reset UI on error/abort
                this.flipDataText(target);
                target.disabled = false;
                                benchTool.endTest(); // End test state management

                // STOP BEAST MODE TIMER ON ERROR/ABORT
                stats.stopTimer();

                markTestArea('running', 'remove');
                markTestArea('finished', 'remove');
            }
        }

        // Infinity Test - Exponential DOM scaling to prove O(1) vs O(n)
        async function infinityTest(target) {
            const abortController = new AbortController();

            try {
                this.flipDataText(target);
                target.disabled = true;

                // Start test state management
                benchTool.startTest('INFINITY TEST', abortController);

                logMessage('∞ INFINITY TEST: Starting exponential DOM scaling to test O(1) vs O(n) performance...', '#e91e63');

                // Get current active container
                const activeContainer = currentMode === 'manual'
                    ? document.getElementById('manualElements')
                    : document.getElementById('ypsilonElements');

                if (activeContainer.innerHTML) {
                    // Simply duplicate the existing content
                    activeContainer.insertAdjacentHTML('beforeend', activeContainer.innerHTML);
                    // Update element counter after scaling
                    if (benchTool && benchTool.updateElementCount) {
                        benchTool.updateElementCount();
                    }
                }

                setTimeout(() => {
                    this.flipDataText(target);
                    target.disabled = false;
                                        benchTool.endTest(); // End test state management
                }, 1000);

            } catch (error) {
                console.error('Infinity test failed:', error);

                const isAborted = error.message === 'Test aborted';
                if (!isAborted) {
                    logMessage('❌ Infinity test failed: ' + error.message, '#ff5722');
                }

                this.flipDataText(target);
                target.disabled = false;
                                benchTool.endTest(); // End test state management
            }
        }

        // Performance-Optimized Logging System
        const loggingSystem = {
            buffer: [],
            batchTimeout: null,
            logLevel: 'minimal', // 'minimal', 'summary', 'verbose'
            maxEntries: 25,
            keystrokeBuffer: new Map(), // For aggregating keystrokes

            setLogLevel(level) {
                // Prevent duplicate calls
                if (this.logLevel === level) return;

                this.logLevel = level;
                const messages = {
                    minimal: '⚡ Minimal logging: Only essential messages',
                    summary: '📊 Summary logging: Aggregated events for performance',
                    verbose: '🔍 Verbose logging: Every single event (may impact performance)'
                };
                logMessage(messages[level], '#FF6B35');
            },

            batchLog(entry) {
                this.buffer.push(entry);

                // Clear existing timeout
                if (this.batchTimeout) clearTimeout(this.batchTimeout);

                // Batch flush using requestAnimationFrame for smooth performance
                this.batchTimeout = setTimeout(() => {
                    requestAnimationFrame(() => {
                        this.flushBuffer();
                    });
                }, 50); // 50ms batching
            },

            flushBuffer() {
                if (this.buffer.length === 0) return;

                const fragment = document.createDocumentFragment();

                // Process keystroke aggregation
                this.processKeystrokeAggregation();

                // Add buffered entries
                this.buffer.forEach(entry => fragment.appendChild(entry));

                // Maintain max entries limit
                while (eventLog.children.length + this.buffer.length > this.maxEntries && eventLog.firstChild) {
                    eventLog.removeChild(eventLog.firstChild);
                }

                eventLog.appendChild(fragment);
                this.buffer = [];

                // Auto-scroll to bottom
                eventLog.scrollTop = eventLog.scrollHeight;
            },

            processKeystrokeAggregation() {
                for (const [targetId, data] of this.keystrokeBuffer) {
                    if (data.count > 1) {
                        const entry = document.createElement('div');
                        entry.className = 'log-entry';
                        entry.innerHTML = `
                            <span class="log-date" style="color:${data.color};">[${data.lastTime}]</span>
                            <span class="handler-type" style="color:${data.color};">📝 ${data.type}</span>
                            <small>→</small> <span class="method-note" title="Typed aggregated">Typed "${data.fullText}" (${data.count} keys)</span>
                            <small>→</small> <span class="log-data-last-col" title="${data.target}">${data.target}</span>
                        `;
                        this.buffer.push(entry);
                        // Keystroke stats already counted individually above
                    }
                }
                this.keystrokeBuffer.clear();
            }
        };

        // 📊 LOG LEVEL HELPER FUNCTION
        function getLogLevel() {
            return loggingSystem.logLevel || 'minimal';
        }

        // Quantum Based Logger
        function logEvent(handlerType, methodName, target, color = '#00ff00') {
            const timestamp = BenchMarkHandler.getTimestamp();

            let targetInfo = target.tagName.toLowerCase();
            if (target.id) targetInfo += `#${target.id}`;
            if (target.dataset && target.dataset.action) targetInfo += `[action:${target.dataset.action}]`;

            // Always update statistics regardless of log level
            stats.eventCount++;
            stats.updateEventsPerSecond();
            document.getElementById('eventCount').textContent = stats.eventCount;

            // Update benchmark progress
            const benchmarkProgress = document.getElementById('benchmarkProgress');
            const benchmarkBar = document.getElementById('benchmarkBar');
            const expected = calculateActualExpectedEvents(); // Use same calculation as final results

            if (benchmarkProgress) {
                benchmarkProgress.textContent = `${stats.eventCount} / ${expected.expectedEvents}`;
                // Color code progress: green when complete, blue while in progress
                if (stats.eventCount === expected.expectedEvents) {
                    benchmarkProgress.style.color = '#4caf50'; // Green when complete
                    benchmarkProgress.style.fontWeight = 'bold';
                } else if (stats.eventCount > expected.expectedEvents) {
                    benchmarkProgress.style.color = '#ff9800'; // Orange when exceeded
                    benchmarkProgress.style.fontWeight = 'bold';
                } else {
                    benchmarkProgress.style.color = '#2196f3'; // Blue while in progress
                    benchmarkProgress.style.fontWeight = 'normal';
                }
            }
            if (benchmarkBar) {
                const percentage = Math.min((stats.eventCount / expected.expectedEvents) * 100, 100);
                benchmarkBar.style.width = percentage + '%';

                // Change color based on progress
                if (stats.eventCount >= expected.expectedEvents) {
                    benchmarkBar.style.background = '#28a745'; // Success green
                } else if (stats.eventCount >= 2500) {
                    benchmarkBar.style.background = 'linear-gradient(90deg, #ffc107, #dc3545)'; // Warning to danger
                } else {
                    benchmarkBar.style.background = 'linear-gradient(90deg, #28a745, #17a2b8)'; // Default
                }
            }

            // Handle different log levels
            if (loggingSystem.logLevel === 'minimal') {
                // Only log important messages, skip all events (but stats still count)
                return;
            }

            // Keystroke aggregation for text inputs (summary and minimal modes)
            if (target.type === 'text' && methodName && methodName.length === 1 && loggingSystem.logLevel !== 'verbose') {
                const targetId = target.id || target.tagName + Math.random().toString(36).substr(2, 9);

                if (!loggingSystem.keystrokeBuffer.has(targetId)) {
                    loggingSystem.keystrokeBuffer.set(targetId, {
                        type: handlerType,
                        target: targetInfo,
                        fullText: '',
                        count: 0,
                        color: color,
                        lastTime: timestamp
                    });
                }

                const data = loggingSystem.keystrokeBuffer.get(targetId);
                data.fullText += methodName;
                data.count++;
                data.lastTime = timestamp;

                return; // Skip individual keystroke logging
            }

            // Skip verbose logging during stress tests unless in verbose mode
            if (loggingSystem.logLevel === 'summary' && testState.isRunning &&
                (methodName === 'onClick' || methodName === 'onChange' || methodName === 'onInput')) {
                return;
            }

            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.innerHTML = `
                <span class="log-date" style="color:${color};">[${timestamp}]</span>
                <span class="handler-type" style="color:${color};">${handlerType}</span>
                <small>→</small> <span class="method-note" title="${methodName}">${methodName}</span>
                <small>→</small> <span class="log-data-last-col" title="${targetInfo}">${targetInfo}</span>
            `;

            // Use batched logging for performance
            loggingSystem.batchLog(entry);
        }

        function logMessage(messsage, color = '#00ff00') {
            const timestamp = BenchMarkHandler.getTimestamp();
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.innerHTML = `
                <span class="log-date" style="color:${color};">[${timestamp}]</span>
                <span class="handler-type" style="color:${color};">${messsage}</span>
            `;
            eventLog.appendChild(entry);
            eventLog.scrollTop = eventLog.scrollHeight;
        }

        // Common handler for all events
        function handleCommonEvent(event, actionPrefix = '') {
            const target = event.target;
            let action = 'unknown';

            if (target.dataset && target.dataset.action) {
                action = target.value || target.dataset.action;

                // Once Only mode: remove data-action to ensure element is touched only once
                if (benchmarkConfig.test.onceOnly && currentMode === 'manual') {
                    target.removeAttribute('data-action');
                    const elementType = target.type || target.tagName.toLowerCase();
                    logMessage(`🎯 Once Only: Removed data-action from ${elementType} element (Manual)`, '#FFA500');
                }
            } else if (target.tagName === 'BUTTON') {
                action = target.textContent.trim().toLowerCase().replace(/\s+/g, '-');
            } else if (target.id) {
                action = target.id;
            }

            if (!target.value) {
                action = actionPrefix + action;
            }

            logEvent(currentMode === 'manual' ? 'Manual' : 'Ypsilon',
                    action,
                    target,
                    currentMode === 'manual' ? '#4a6fa5' : '#00aa88');
        }

        // Helper to create elements
        function createElement(type, index, addAction) {
            let element,
                label,
                labelChild,
                labelWrapper;

            // Realistic action names for different element types
            const buttonActions = ['saveData', 'deleteItem', 'editRecord', 'submitForm', 'cancelAction'];
            const inputActions = ['updateUsername', 'updateEmail', 'updatePassword', 'searchQuery'];
            const checkboxActions = ['toggleNotifications', 'enableFeature'];
            const radioActions = ['selectTheme', 'setPrivacyLevel'];
            const selectActions = ['changeLanguage', 'selectCountry', 'chooseCategory', 'pickTimezone'];

            // Pick a random amount of options to use, so they differ
            const selectOptions = [
                { value: 'option1', text: 'Option 1' },
                { value: 'option2', text: 'Option 2' },
                { value: 'option3', text: 'Option 3' },
                { value: 'option4', text: 'Option 4' },
                { value: 'option5', text: 'Option 5' },
                { value: 'option6', text: 'Option 6' },
                { value: 'option7', text: 'Option 7' },
                { value: 'option8', text: 'Option 8' },
                { value: 'option9', text: 'Option 9' },
                { value: 'option10', text: 'Option 10' },
            ];

            switch (type) {
                case 'button':
                    element = document.createElement('button');
                    element.className = 'test-button';
                    const buttonAction = buttonActions[index % buttonActions.length];
                    element.textContent = buttonAction ? `${buttonAction.replace(/([A-Z])/g, ' $1').trim()} ${index}` : `Button ${index}`;
                    if (addAction && buttonAction) {
                        element.dataset.action = buttonAction;
                    }
                    break;
                case 'text':
                    element = document.createElement('input');
                    element.className = 'test-input';
                    element.type = 'text';
                    element.name = `input-${index}`;
                    element.defaultValue = '';
                    const inputAction = inputActions[index % inputActions.length];
                    element.placeholder = inputAction ? `${inputAction.replace(/([A-Z])/g, ' $1').trim()} ${index}` : `Input ${index}`;
                    if (addAction && inputAction) {
                        element.dataset.action = inputAction;
                    }
                    break;
                case 'select':
                    element = document.createElement('select');
                    element.className = 'test-select';
                    element.name = `select-${index}`;

                    const selectAction = selectActions[index % selectActions.length];

                    // Create option elements with realistic values - use random amount from selectOptions
                    const numOptions = Math.floor(Math.random() * 6) + 3; // 3-8 options
                    const shuffledOptions = shuffleArray([...selectOptions]).slice(0, numOptions);

                    const options = [
                        { value: '', text: selectAction ? `${selectAction.replace(/([A-Z])/g, ' $1').trim()} ${index}` : `Select ${index}` },
                        ...shuffledOptions
                    ];

                    options.forEach(opt => {
                        const option = document.createElement('option');
                        option.value = opt.value;
                        option.textContent = opt.text;
                        element.appendChild(option);
                    });

                    if (addAction && selectAction) {
                        element.dataset.action = selectAction;
                    }
                    break;
                case 'checkbox':
                    element = document.createElement('input');
                    label = document.createElement('label');
                    labelChild = document.createElement('span');
                    labelWrapper = document.createElement('div');

                    labelWrapper.className = 'test-checkbox-wrap';
                    element.className = 'test-checkbox';
                    element.type = 'checkbox';
                    element.name = `checkbox-${index}`;
                    // No ID needed - nested in label for automatic association
                    const checkboxAction = checkboxActions[index % checkboxActions.length];
                    labelChild.textContent = checkboxAction ? `${checkboxAction.replace(/([A-Z])/g, ' $1').trim()} ${index}` : `Checkbox ${index}`;

                    if (addAction && checkboxAction) {
                        element.dataset.action = checkboxAction;
                    }

                    label.appendChild(element);
                    label.appendChild(labelChild);
                    labelWrapper.appendChild(label);

                    return labelWrapper;
                case 'radio':
                    element = document.createElement('input');
                    label = document.createElement('label');
                    labelChild = document.createElement('span');
                    labelWrapper = document.createElement('div');

                    labelWrapper.className = 'test-checkbox-radio';
                    element.className = 'test-radio';
                    element.type = 'radio';
                    // Create separate radio groups to avoid conflicts
                    element.name = `radio-group-${Math.floor(index / 5)}`; // Groups of 5 radios
                    element.value = `radio-value-${index}`;
                    // No ID needed - nested in label for automatic association
                    const radioAction = radioActions[index % radioActions.length];
                    labelChild.textContent = radioAction ? `${radioAction.replace(/([A-Z])/g, ' $1').trim()} ${index}` : `Radio ${index}`;

                    if (addAction && radioAction) {
                        element.dataset.action = radioAction;
                    }

                    label.appendChild(element);
                    label.appendChild(labelChild);
                    labelWrapper.appendChild(label);

                    return labelWrapper;
            }

            return element;
        }

        function createNestedStructure(element, depth) {
            if (depth <= 0) return element;

            const wrapper = document.createElement('div');
            wrapper.style.paddingLeft = '3px';
            wrapper.style.margin = '1px 0';
            wrapper.style.borderLeft = '1px solid #ddd';

            wrapper.appendChild(element);
            return createNestedStructure(wrapper, depth - 1);
        }

        function generateAllElementsOnly() {
            states.elementsCreated = currentMode;

            // Generate all element types in both containers
            if (currentMode === 'manual') {
                generateAllElements('manualElements', true);
            } else {
                generateAllElements('ypsilonElements', false);
            }
        }

        function generateAllElements(containerId, isManual) {
            const container = document.getElementById(containerId);
            const elementTypes = ['button', 'text', 'checkbox', 'radio', 'select'];

            container.innerHTML = ''; // Clear existing elements

            const numKeys = {
                button:   'createTotalButton',
                text:     'createTotalText',
                checkbox: 'createTotalCheckbox',
                radio:    'createTotalRadiobox',
                select:   'createTotalSelect',
                div:      'createTotalDiv',
            };

            elementTypes.forEach(type => {
                const counterConfigKey = numKeys[type];
                const total = benchmarkConfig.test[counterConfigKey];

                if (!total) return;

                for (let i = 0; i < total; i++) {
                    const element = createElement(type, i, true);

                    // Apply nesting structure if configured
                    const nestingDepth = parseInt(benchmarkConfig.test.nestingDepth) || 0;
                    const finalElement = createNestedStructure(element, nestingDepth);
                    container.appendChild(finalElement);

                    // Manual listener management nightmare - traditional approach
                    if (isManual) {
                        if (type === 'button') {
                            const actualElement = element.tagName === 'DIV' ? element.querySelector('input, button') : element;

                            // Traditional approach: individual handlers with bind() - memory leak prone
                            function handleButtonClick(event) {
                                handleCommonEvent(event);
                            }

                            // Bind to preserve context (creates new function every time - leak!)
                            const boundHandler = handleButtonClick.bind(this);
                            actualElement.addEventListener('click', boundHandler);

                            // Must track bound functions for cleanup nightmare
                            manualListeners.set(actualElement, {
                                type: 'click',
                                handler: boundHandler,
                                originalHandler: handleButtonClick
                            });
                        }
                        else if (type === 'text') {
                            // Traditional approach: separate handler functions with bind()
                            function handleTextInput(event) {
                                handleCommonEvent(event, 'input-');
                            }

                            // Bind creates new function reference - memory overhead
                            const boundHandler = handleTextInput.bind(this);
                            element.addEventListener('input', boundHandler);

                            manualListeners.set(element, {
                                type: 'input',
                                handler: boundHandler,
                                originalHandler: handleTextInput
                            });
                        }
                        else if (type === 'checkbox' || type === 'radio') {
                            const actualElement = element.querySelector('input');

                            // Traditional approach: different handler per element type
                            function handleCheckboxRadioChange(event) {
                                handleCommonEvent(event, 'change-');
                            }

                            // More bind() calls = more memory overhead
                            const boundHandler = handleCheckboxRadioChange.bind(this);
                            actualElement.addEventListener('change', boundHandler);

                            manualListeners.set(actualElement, {
                                type: 'change',
                                handler: boundHandler,
                                originalHandler: handleCheckboxRadioChange
                            });
                        }
                        else if (type === 'select') {
                            // Traditional approach: separate handler for select elements
                            function handleSelectChange(event) {
                                handleCommonEvent(event, 'select-');
                            }

                            // Another bind() call = more memory overhead
                            const boundHandler = handleSelectChange.bind(this);
                            element.addEventListener('change', boundHandler);

                            manualListeners.set(element, {
                                type: 'change',
                                handler: boundHandler,
                                originalHandler: handleSelectChange
                            });
                        }
                    }
                }
            });
        }

        function markTestArea(setState, fn = 'add') {
            document.querySelector('.test-area').classList[fn](setState);
        }


        // Initialize with manual mode
        benchTool.setMode(document.querySelector('.active[data-action="setMode"]'));
    </script>

    <div class="src-nav">
        <nav>
            <small><i>© Sunny DeepSeek & Claude Van DOM & Engin Ypsilon</i></small>
        </nav>
    </div>

</body>
</html>
